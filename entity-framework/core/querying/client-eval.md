---
title: İstemci ve Sunucu Değerlendirmesi - EF Core
author: smitpatel
ms.date: 10/03/2019
ms.assetid: 8b6697cc-7067-4dc2-8007-85d80503d123
uid: core/querying/client-eval
ms.openlocfilehash: e01bd146c4dfe7a8d36b641cb52ae366fddd8239
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/07/2020
ms.locfileid: "78417762"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="d4da8-102">İstemci ve Sunucu Değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="d4da8-102">Client vs. Server Evaluation</span></span>

<span data-ttu-id="d4da8-103">Genel bir kural olarak, Entity Framework Core sunucudaki bir sorguyu mümkün olduğunca değerlendirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="d4da8-103">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="d4da8-104">EF Core, sorgunun bazı bölümlerini istemci tarafında değerlendirebileceği parametrelere dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="d4da8-104">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="d4da8-105">Sorgunun geri kalanı (oluşturulan parametrelerle birlikte) sunucuda değerlendirilecek eşdeğer veritabanı sorgusunu belirlemek üzere veritabanı sağlayıcısına verilir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-105">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="d4da8-106">EF Core, üst düzey projeksiyonda kısmi istemci değerlendirmesini destekler `Select()`(aslında, son çağrı).</span><span class="sxs-lookup"><span data-stu-id="d4da8-106">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="d4da8-107">Sorgudaki üst düzey projeksiyon sunucuya çevrilemezse, EF Core sunucudan gerekli verileri alır ve istemcide sorgunun kalan bölümlerini değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-107">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="d4da8-108">EF Core, sunucuya çevrilemez üst düzey projeksiyon dışında herhangi bir yerde bir ifade algılarsa, o zaman bir çalışma zamanı özel durum atar.</span><span class="sxs-lookup"><span data-stu-id="d4da8-108">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="d4da8-109">EF Core'un sunucuya çevrilemeyecek leri nasıl belirlediğini anlamak için [sorgunun nasıl çalıştığını](xref:core/querying/how-query-works) görün.</span><span class="sxs-lookup"><span data-stu-id="d4da8-109">See [how query works](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="d4da8-110">Sürüm 3.0'dan önce, Entity Framework Core sorgunun herhangi bir yerindeki istemci değerlendirmesini destekledi.</span><span class="sxs-lookup"><span data-stu-id="d4da8-110">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="d4da8-111">Daha fazla bilgi için [önceki sürümler bölümüne](#previous-versions)bakın.</span><span class="sxs-lookup"><span data-stu-id="d4da8-111">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="d4da8-112">Bu makalenin [örneğini](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) GitHub'da görüntüleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d4da8-112">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="d4da8-113">Üst düzey projeksiyonda müşteri değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="d4da8-113">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="d4da8-114">Aşağıdaki örnekte, SQL Server veritabanından döndürülen bloglar için URL'leri standartlaştırmak için yardımcı yöntemi kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d4da8-114">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="d4da8-115">SQL Server sağlayıcısının bu yöntemin nasıl uygulandığına dair bir içgörüsü olmadığından, bu yöntemin SQL'e çevrilmesi mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-115">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="d4da8-116">Sorgunun diğer tüm yönleri veritabanında değerlendirilir, ancak `URL` bu yöntem üzerinden döndürülen istemci üzerinde yapılır.</span><span class="sxs-lookup"><span data-stu-id="d4da8-116">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="d4da8-117">Desteklenmeyen istemci değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="d4da8-117">Unsupported client evaluation</span></span>

<span data-ttu-id="d4da8-118">İstemci değerlendirmesi yararlı olsa da, bazen düşük performansa neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-118">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="d4da8-119">Yardımcı yönteminin artık bir where filtresinde kullanıldığı aşağıdaki sorguyu göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="d4da8-119">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="d4da8-120">Filtre veritabanında uygulanamadığından, istemciye filtre uygulamak için tüm verilerin belleğe çekilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-120">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="d4da8-121">Filtreye ve sunucudaki veri miktarına bağlı olarak, istemci değerlendirmesi düşük performansa neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-121">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="d4da8-122">Yani Entity Framework Core bu tür istemci değerlendirmesini engeller ve çalışma zamanı özel bir durum atar.</span><span class="sxs-lookup"><span data-stu-id="d4da8-122">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="d4da8-123">Açık istemci değerlendirmesi</span><span class="sxs-lookup"><span data-stu-id="d4da8-123">Explicit client evaluation</span></span>

<span data-ttu-id="d4da8-124">Aşağıdaki gibi bazı durumlarda açıkça müşteri değerlendirmesine zorlamanız gerekebilir</span><span class="sxs-lookup"><span data-stu-id="d4da8-124">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="d4da8-125">Veri miktarı küçüktür, böylece istemci üzerinde değerlendirme büyük bir performans cezasına neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="d4da8-125">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="d4da8-126">Kullanılan LINQ işlecinin sunucu tarafı çevirisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="d4da8-126">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="d4da8-127">Bu gibi durumlarda, `AsEnumerable` gibi veya `ToList` (veya`AsAsyncEnumerable` `ToListAsync` async) gibi yöntemleri arayarak açıkça istemci değerlendirmesini tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d4da8-127">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="d4da8-128">Kullanarak `AsEnumerable` sonuçları akışı olurdu, ancak `ToList` kullanarak da ek bellek alır bir liste oluşturarak arabelleğe alma neden olur.</span><span class="sxs-lookup"><span data-stu-id="d4da8-128">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="d4da8-129">Birden çok kez sıralama ediyorsanız, veritabanında yalnızca bir sorgu olduğundan sonuçları bir listede depolamak daha fazla yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="d4da8-129">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="d4da8-130">Belirli kullanıma bağlı olarak, hangi yöntemin servis talebi için daha yararlı olduğunu değerlendirmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="d4da8-130">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ExplicitClientEval)]

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="d4da8-131">İstemci değerlendirmesinde olası bellek sızıntısı</span><span class="sxs-lookup"><span data-stu-id="d4da8-131">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="d4da8-132">Sorgu çevirisi ve derleme pahalı olduğundan, EF Core derlenmiş sorgu planını önbelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="d4da8-132">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="d4da8-133">Önbelleğe alınan temsilci, üst düzey projeksiyonun istemci değerlendirmesini yaparken istemci kodunu kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-133">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="d4da8-134">EF Core, ağacın istemci tarafından değerlendirilen bölümleri için parametreler oluşturur ve parametre değerlerini değiştirerek sorgu planını yeniden kullanır.</span><span class="sxs-lookup"><span data-stu-id="d4da8-134">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="d4da8-135">Ancak ifade ağacındaki bazı sabitler parametreye dönüştürülemez.</span><span class="sxs-lookup"><span data-stu-id="d4da8-135">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="d4da8-136">Önbelleğe alınan temsilci bu tür sabitleri içeriyorsa, bu nesneler hala başvurulmakta oldukları için çöp olarak toplanabilir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-136">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="d4da8-137">Böyle bir nesne içinde bir DbContext veya başka hizmetler içeriyorsa, uygulamanın bellek kullanımının zaman içinde büyümesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-137">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="d4da8-138">Bu davranış genellikle bir bellek sızıntısının bir işaretidir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-138">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="d4da8-139">EF Core, geçerli veritabanı sağlayıcısı kullanılarak eşlenemez bir tür sabitleri karşılaştığında bir özel durum atar.</span><span class="sxs-lookup"><span data-stu-id="d4da8-139">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="d4da8-140">Ortak nedenleri ve çözümleri aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="d4da8-140">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="d4da8-141">**Örnek yöntemi kullanma**: Bir istemci projeksiyonunda örnek yöntemlerini kullanırken, ifade ağacı örneğin sabitini içerir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-141">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="d4da8-142">Yönteminiz örnekten herhangi bir veri kullanmıyorsa, yöntemi statik hale getirmeyi düşünün.</span><span class="sxs-lookup"><span data-stu-id="d4da8-142">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="d4da8-143">Yöntem gövdesinde örnek verilere ihtiyacınız varsa, belirli verileri bir bağımsız değişken olarak yönteme geçirin.</span><span class="sxs-lookup"><span data-stu-id="d4da8-143">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="d4da8-144">**Sabit bağımsız değişkenleri yönteme geçirme**: `this` Bu durum genellikle bir bağımsız değişkende istemci yöntemi kullanılarak ortaya çıkar.</span><span class="sxs-lookup"><span data-stu-id="d4da8-144">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="d4da8-145">Bağımsız değişkeni veritabanı sağlayıcısı tarafından eşlenen birden çok skaler bağımsız değişkene bölmeyi düşünün.</span><span class="sxs-lookup"><span data-stu-id="d4da8-145">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="d4da8-146">**Diğer sabitler**: Başka bir durumda bir sabit rastlarsa, o zaman sabitin işlenmesinde gerekli olup olmadığını değerlendirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d4da8-146">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="d4da8-147">Sabite sahip olmak gerekiyorsa veya yukarıdaki durumlardan bir çözüm kullanamıyorsanız, değeri depolamak ve sorguda yerel değişkeni kullanmak için yerel bir değişken oluşturun.</span><span class="sxs-lookup"><span data-stu-id="d4da8-147">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="d4da8-148">EF Core yerel değişkeni bir parametreye dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="d4da8-148">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="d4da8-149">Önceki sürümler</span><span class="sxs-lookup"><span data-stu-id="d4da8-149">Previous versions</span></span>

<span data-ttu-id="d4da8-150">Aşağıdaki bölüm 3.0'dan önceki EF Core sürümleri için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-150">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="d4da8-151">Eski EF Core sürümleri, yalnızca üst düzey projeksiyonu değil, sorgunun herhangi bir bölümünde istemci değerlendirmesini desteklenebilmiştir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-151">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="d4da8-152">Bu nedenle [Desteklenmeyen istemci değerlendirme](#unsupported-client-evaluation) bölümü altında deftere nakledilene benzer sorgular doğru çalıştı.</span><span class="sxs-lookup"><span data-stu-id="d4da8-152">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="d4da8-153">Bu davranış fark edilmeyen performans sorunlarına neden olabileceğinden, EF Core bir istemci değerlendirme uyarısı günlüğe kaydetmiştir.</span><span class="sxs-lookup"><span data-stu-id="d4da8-153">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="d4da8-154">Günlüğe kaydetme çıktısını görüntüleme hakkında daha fazla bilgi için [Günlük'](xref:core/miscellaneous/logging)e bakın.</span><span class="sxs-lookup"><span data-stu-id="d4da8-154">For more information on viewing logging output, see [Logging](xref:core/miscellaneous/logging).</span></span>

<span data-ttu-id="d4da8-155">İsteğe bağlı olarak EF Core, varsayılan davranışı bir özel durum atmak veya istemci değerlendirmesi yaparken hiçbir şey yapmamak için (projeksiyon hariç) değiştirmenize olanak sağladı.</span><span class="sxs-lookup"><span data-stu-id="d4da8-155">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="d4da8-156">Özel durum atma davranışı 3.0'daki davranışa benzer hale getirecek.</span><span class="sxs-lookup"><span data-stu-id="d4da8-156">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="d4da8-157">Davranışı değiştirmek için, bağlamınıziçin seçenekleri ayarlarken uyarıları yapılandırmanız gerekir `DbContext.OnConfiguring`- genellikle `Startup.cs` ASP.NET Core'da veya burada.</span><span class="sxs-lookup"><span data-stu-id="d4da8-157">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
