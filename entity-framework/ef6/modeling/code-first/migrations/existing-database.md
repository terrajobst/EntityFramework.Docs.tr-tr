---
title: Code First Migrations ile varolan bir veritabanını - EF6
author: divega
ms.date: 2016-10-23
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
ms.openlocfilehash: 06aabf3f57ca451f4d9cba469f6de40fd9aa8f23
ms.sourcegitcommit: dadee5905ada9ecdbae28363a682950383ce3e10
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/27/2018
ms.locfileid: "42998203"
---
# <a name="code-first-migrations-with-an-existing-database"></a><span data-ttu-id="f1a3f-102">Code First Migrations ile mevcut bir veritabanı</span><span class="sxs-lookup"><span data-stu-id="f1a3f-102">Code First Migrations with an existing database</span></span>
> [!NOTE]
> <span data-ttu-id="f1a3f-103">**EF4.3 ve sonraki sürümler yalnızca** -özellikler, API'ler, bu sayfada açıklanan vb. Entity Framework 4.1 içinde kullanıma sunulmuştur.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-103">**EF4.3 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 4.1.</span></span> <span data-ttu-id="f1a3f-104">Önceki bir sürümü kullanıyorsanız, bazı veya tüm bilgileri geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-104">If you are using an earlier version, some or all of the information does not apply.</span></span>

<span data-ttu-id="f1a3f-105">Bu makale, Entity Framework tarafından oluşturulmadıysa var olan veritabanı ile Code First Migrations'ı kullanarak kapsar.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-105">This article covers using Code First Migrations with an existing database, one that wasn’t created by Entity Framework.</span></span>

> [!NOTE]
> <span data-ttu-id="f1a3f-106">Bu makalede, temel senaryolarda Code First Migrations nasıl kullanılacağını varsayar.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-106">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="f1a3f-107">Sizin sonra okumak ihtiyacınız olacak [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) devam etmeden önce.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-107">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="screencasts"></a><span data-ttu-id="f1a3f-108">Ekran kayıtları</span><span class="sxs-lookup"><span data-stu-id="f1a3f-108">Screencasts</span></span>

<span data-ttu-id="f1a3f-109">Bu makaleyi okuyun bir yayını daha yerine izleyin, bu makalede aynı içeriğe aşağıdaki iki video kapsar.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-109">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="f1a3f-110">Bir video: "Başlık altında - geçişler"</span><span class="sxs-lookup"><span data-stu-id="f1a3f-110">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="f1a3f-111">[Bu yayını](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) geçişleri nasıl izlediği kapsar ve modeli hakkında bilgi modeli değişikliklerini algılamak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-111">[This screencast](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---existing-databases"></a><span data-ttu-id="f1a3f-112">Video iki: "Geçişler - var olan veritabanlarını"</span><span class="sxs-lookup"><span data-stu-id="f1a3f-112">Video Two: "Migrations - Existing Databases"</span></span>

<span data-ttu-id="f1a3f-113">Önceki video kavramları güncelleştirmelerle [bu yayını](http://channel9.msdn.com/blogs/ef/migrations-existing-databases) etkinleştirmek ve var olan bir veritabanı geçişlerini kullanmak nasıl etkinleştireceğinizi de açıklar.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-113">Building on the concepts from the previous video, [this screencast](http://channel9.msdn.com/blogs/ef/migrations-existing-databases) covers how to enable and use migrations with an existing database.</span></span>

## <a name="step-1-create-a-model"></a><span data-ttu-id="f1a3f-114">1. adım: bir model oluşturma</span><span class="sxs-lookup"><span data-stu-id="f1a3f-114">Step 1: Create a model</span></span>

<span data-ttu-id="f1a3f-115">İlk adımınız mevcut veritabanını hedefleyen Code First bir model oluşturmak olacaktır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-115">Your first step will be to create a Code First model that targets your existing database.</span></span> <span data-ttu-id="f1a3f-116">[Var olan bir veritabanına ilk kod](~/ef6/modeling/code-first/workflows/existing-database.md) konu bunun nasıl yapılacağı hakkında ayrıntılı kılavuz sağlar.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-116">The [Code First to an Existing Database](~/ef6/modeling/code-first/workflows/existing-database.md) topic provides detailed guidance on how to do this.</span></span>

>[!NOTE]
> <span data-ttu-id="f1a3f-117">Veritabanı şema değişiklikleri gerektirecek modeldeki herhangi bir değişiklik yapmadan önce bu konudaki adımları izlemeden daha önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-117">It is important to follow the rest of the steps in this topic before making any changes to your model that would require changes to the database schema.</span></span> <span data-ttu-id="f1a3f-118">Model eşitlenmiş olması için aşağıdaki adımları gerektirir veritabanı şeması.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-118">The following steps require the model to be in-sync with the database schema.</span></span>

## <a name="step-2-enable-migrations"></a><span data-ttu-id="f1a3f-119">2. adım: Migrations'ı etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="f1a3f-119">Step 2: Enable Migrations</span></span>

<span data-ttu-id="f1a3f-120">Sonraki adım, geçiş etkinleştirmektir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-120">The next step is to enable migrations.</span></span> <span data-ttu-id="f1a3f-121">Çalıştırarak bunu yapabilirsiniz **etkinleştir geçişleri** Paket Yöneticisi konsolunda komutu.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-121">You can do this by running the **Enable-Migrations** command in Package Manager Console.</span></span>

<span data-ttu-id="f1a3f-122">Bu komut çözümünüzde geçişleri adlı bir klasör oluşturun ve tek bir sınıf adlı yapılandırma içinde yerleştirin.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-122">This command will create a folder in your solution called Migrations, and put a single class inside it called Configuration.</span></span> <span data-ttu-id="f1a3f-123">Yapılandırma geçişleri uygulamanız için daha fazla bilgi bulabilirsiniz yapılandırdığınız sınıftır [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) konu.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-123">The Configuration class is where you configure migrations for your application, you can find out more about it in the [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) topic.</span></span>

## <a name="step-3-add-an-initial-migration"></a><span data-ttu-id="f1a3f-124">3. adım: bir başlangıç geçiş Ekle</span><span class="sxs-lookup"><span data-stu-id="f1a3f-124">Step 3: Add an initial migration</span></span>

<span data-ttu-id="f1a3f-125">Geçiş oluşturulur ve uygulanan sonra bunlar uygulamak isteyebilirsiniz yerel veritabanı diğer veritabanlarına değişir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-125">Once migrations have been created and applied to the local database you may also want to apply these changes to other databases.</span></span> <span data-ttu-id="f1a3f-126">Örneğin, yerel veritabanınızı bir test veritabanı olabilir ve sonuçta da üretim veritabanına değişiklikleri uygulamak isteyebilirsiniz ve/veya diğer geliştiriciler veritabanları test edin.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-126">For example, your local database may be a test database and you may ultimately want to also apply the changes to a production database and/or other developers test databases.</span></span> <span data-ttu-id="f1a3f-127">Bu adım için iki seçenek vardır ve diğer veritabanlarını şemasını boş veya şu anda yerel veritabanı şeması eşleşen olup olmadığını seçmeniz gerekir bir bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-127">There are two options for this step and the one you should pick depends whether or not the schema of any other databases is empty or currently matches the schema of the local database.</span></span>

-   <span data-ttu-id="f1a3f-128">**Bir seçenek: var olan bir şema, başlangıç noktası olarak kullanın.**</span><span class="sxs-lookup"><span data-stu-id="f1a3f-128">**Option One: Use existing schema as starting point.**</span></span> <span data-ttu-id="f1a3f-129">Yerel veritabanınızı şu anda olduğu gibi geçişleri gelecekte uygulanacak diğer veritabanları aynı şemaya sahip olduğunda bu yaklaşımı kullanmanız.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-129">You should use this approach when other databases that migrations will be applied to in the future will have the same schema as your local database currently has.</span></span> <span data-ttu-id="f1a3f-130">Örneğin, bu yerel test veritabanınız şu anda v1 üretim veritabanınız ile eşleşen ve daha sonra bu geçişlerini üretim veritabanınızı v2 için güncelleştirme uygulanır kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-130">For example, you might use this if your local test database currently matches v1 of your production database and you will later apply these migrations to update your production database to v2.</span></span>
-   <span data-ttu-id="f1a3f-131">**İki seçenek: boş veritabanı, başlangıç noktası olarak kullanın.**</span><span class="sxs-lookup"><span data-stu-id="f1a3f-131">**Option Two: Use empty database as starting point.**</span></span> <span data-ttu-id="f1a3f-132">Geçişleri gelecekte uygulanacak diğer veritabanlarına boş (veya henüz var olmaması olduğunda), bu yaklaşımı kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-132">You should use this approach when other databases that migrations will be applied to in the future are empty (or do not exist yet).</span></span> <span data-ttu-id="f1a3f-133">Örneğin, bir test veritabanı kullanarak uygulamanızı geliştirmeye başladı, ancak geçişleri ve kullanmadan daha sonra bir üretim veritabanının sıfırdan oluşturmak isteyeceksiniz bu kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-133">For example, you might use this if you started developing your application using a test database but without using migrations and you will later want to create a production database from scratch.</span></span>

### <a name="option-one-use-existing-schema-as-a-starting-point"></a><span data-ttu-id="f1a3f-134">Bir seçenek: var olan şema başlangıç noktası olarak kullanın.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-134">Option One: Use existing schema as a starting point</span></span>

<span data-ttu-id="f1a3f-135">Code First geçişleri modeline değişikliklerini algılamak için modelinin en son geçiş depolanan anlık görüntüsünü kullanır (Bu konuda hakkında ayrıntılı bilgi bulabilirsiniz [Code First Migrations ekip ortamlarında](~/ef6/modeling/code-first/migrations/teams.md)).</span><span class="sxs-lookup"><span data-stu-id="f1a3f-135">Code First Migrations uses a snapshot of the model stored in the most recent migration to detect changes to the model (you can find detailed information about this in [Code First Migrations in Team Environments](~/ef6/modeling/code-first/migrations/teams.md)).</span></span> <span data-ttu-id="f1a3f-136">Veritabanları, geçerli model şeması zaten sahip olduğunuzu varsaymaktadır kullanacağız olduğundan, bir anlık görüntü olarak geçerli modeli olan bir boş (İşlemsiz) geçiş oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-136">Since we are going to assume that databases already have the schema of the current model, we will generate an empty (no-op) migration that has the current model as a snapshot.</span></span>

1.  <span data-ttu-id="f1a3f-137">Çalıştırma **Ekle geçiş InitialCreate – IgnoreChanges** Paket Yöneticisi konsolunda komutu.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-137">Run the **Add-Migration InitialCreate –IgnoreChanges** command in Package Manager Console.</span></span> <span data-ttu-id="f1a3f-138">Bu boş bir geçiş geçerli modeliyle anlık görüntü olarak oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-138">This creates an empty migration with the current model as a snapshot.</span></span>
2.  <span data-ttu-id="f1a3f-139">Çalıştırma **veritabanını Güncelleştir** Paket Yöneticisi konsolunda komutu.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-139">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="f1a3f-140">Bu, InitialCreate geçiş veritabanına uygulanır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-140">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="f1a3f-141">Gerçek geçiş herhangi bir değişiklik içermiyor olduğundan, yalnızca bir satır için ekleyeceksiniz \_ \_bu geçiş zaten uygulanmış olan tablo MigrationsHistory belirten.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-141">Since the actual migration doesn’t contain any changes, it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>

### <a name="option-two-use-empty-database-as-a-starting-point"></a><span data-ttu-id="f1a3f-142">İki seçenek: boş veritabanı bir başlangıç noktası olarak kullanın.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-142">Option Two: Use empty database as a starting point</span></span>

<span data-ttu-id="f1a3f-143">Bu senaryoda sıfırdan – bizim yerel veritabanında mevcut olan tablolar da dahil olmak üzere tüm veritabanı oluşturabilmeniz için geçişler ihtiyacımız var.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-143">In this scenario we need Migrations to be able to create the entire database from scratch – including the tables that are already present in our local database.</span></span> <span data-ttu-id="f1a3f-144">Varolan şema oluşturmak için mantığı içeren bir InitialCreate geçiş oluşturmak için ekleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-144">We’re going to generate an InitialCreate migration that includes logic to create the existing schema.</span></span> <span data-ttu-id="f1a3f-145">Ardından bu geçiş zaten uygulanmış gibi görünmesini bizim var olan veritabanı oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-145">We’ll then make our existing database look like this migration has already been applied.</span></span>

1.  <span data-ttu-id="f1a3f-146">Çalıştırma **Ekle geçiş InitialCreate** Paket Yöneticisi konsolunda komutu.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-146">Run the **Add-Migration InitialCreate** command in Package Manager Console.</span></span> <span data-ttu-id="f1a3f-147">Bu var olan bir şema oluşturmak için bir geçiş oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-147">This creates a migration to create the existing schema.</span></span>
2.  <span data-ttu-id="f1a3f-148">Yeni oluşturulan geçiş yukarı yönteminde tüm kod açıklama satırı yapın.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-148">Comment out all code in the Up method of the newly created migration.</span></span> <span data-ttu-id="f1a3f-149">Bu, bize 'geçiş için yerel veritabanı zaten mevcut olan tüm tabloları vb. yeniden çalışmadan uygulamak ' olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-149">This will allow us to ‘apply’ the migration to the local database without trying to recreate all the tables etc. that already exist.</span></span>
3.  <span data-ttu-id="f1a3f-150">Çalıştırma **veritabanını Güncelleştir** Paket Yöneticisi konsolunda komutu.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-150">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="f1a3f-151">Bu, InitialCreate geçiş veritabanına uygulanır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-151">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="f1a3f-152">Gerçek geçiş içermediğinden değişiklikleri (biz geçici olarak bunları açıklamalı nedeniyle), genellikle yalnızca bir satır ekler \_ \_bu geçiş zaten uygulanmış olan tablo MigrationsHistory belirten.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-152">Since the actual migration doesn’t contain any changes (because we temporarily commented them out), it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>
4.  <span data-ttu-id="f1a3f-153">Yukarı yöntemindeki kod un açıklama.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-153">Un-comment the code in the Up method.</span></span> <span data-ttu-id="f1a3f-154">Başka bir deyişle, bu geçiş gelecekteki veritabanlarına uygulandığında, yerel veritabanında zaten varolduğu şema geçişleri tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-154">This means that when this migration is applied to future databases, the schema that already existed in the local database will be created by migrations.</span></span>

## <a name="things-to-be-aware-of"></a><span data-ttu-id="f1a3f-155">Dikkat edilmesi gereken noktalar</span><span class="sxs-lookup"><span data-stu-id="f1a3f-155">Things to be aware of</span></span>

<span data-ttu-id="f1a3f-156">Geçişleri var olan bir veritabanında kullanırken bilmeniz gereken birkaç nokta vardır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-156">There are a few things you need to be aware of when using Migrations against an existing database.</span></span>

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a><span data-ttu-id="f1a3f-157">Varsayılan ve hesaplanan adları mevcut şema eşleşmiyor olabilir</span><span class="sxs-lookup"><span data-stu-id="f1a3f-157">Default/calculated names may not match existing schema</span></span>

<span data-ttu-id="f1a3f-158">Geçişleri açıkça belirten sütun ve tabloların adlarını, bir geçiş iskele oluşturulduğunu olduğunda.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-158">Migrations explicitly specifies names for columns and tables when it scaffolds a migrations.</span></span> <span data-ttu-id="f1a3f-159">Ancak, geçişler hesaplar için bir varsayılan ad geçişlerin uygularken diğer veritabanı nesnelerini vardır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-159">However, there are other database objects that Migrations calculates a default name for when applying the migrations.</span></span> <span data-ttu-id="f1a3f-160">Bu, dizinleri ve yabancı anahtar kısıtlamaları içerir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-160">This includes indexes and foreign key constraints.</span></span> <span data-ttu-id="f1a3f-161">Var olan bir şema hedeflenirken Bu hesaplanan adları ne veritabanınızda gerçekten var eşleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-161">When targeting an existing schema, these calculated names may not match what actually exists in your database.</span></span>

<span data-ttu-id="f1a3f-162">Bu durumun farkında olması gerektiğinde bazı örnekleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f1a3f-162">Here are some examples of when you need to be aware of this:</span></span>

<span data-ttu-id="f1a3f-163">**Kullandıysanız ' seçeneği bir: var olan şema başlangıç noktası olarak kullanın. ' adım 3:**</span><span class="sxs-lookup"><span data-stu-id="f1a3f-163">**If you used ‘Option One: Use existing schema as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="f1a3f-164">Değiştirmek veya farklı şekilde adlandırılmış veritabanı nesnelerinden birine bırakarak, modelinize ileride yapılacak değişikliklerin ihtiyacınız varsa, doğru adı belirtmek için iskele kurulmuş geçiş değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-164">If future changes in your model require changing or dropping one of the database objects that is named differently, you will need to modify the scaffolded migration to specify the correct name.</span></span> <span data-ttu-id="f1a3f-165">Geçişleri API'leri, bunu yapmanızı sağlayan isteğe bağlı adı parametresi var.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-165">The Migrations APIs have an optional Name parameter that allows you to do this.</span></span>
    <span data-ttu-id="f1a3f-166">Örneğin, var olan şemanızı IndexFk adlı bir dizin olan bir BlogId yabancı anahtar sütunu içeren bir gönderi tablo olabilir\_BlogId.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-166">For example, your existing schema may have a Post table with a BlogId foreign key column that has an index named IndexFk\_BlogId.</span></span> <span data-ttu-id="f1a3f-167">Varsayılan olarak bu dizin IX adlandırılması geçişleri ancak beklediğiniz\_BlogId.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-167">However, by default Migrations would expect this index to be named IX\_BlogId.</span></span> <span data-ttu-id="f1a3f-168">Bu dizini bırakma sonucunda modeldeki bir değişiklik yaparsanız, IndexFk belirtmek için iskele kurulmuş DropIndex çağrısı değiştirmeniz gerekecektir\_BlogId adı.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-168">If you make a change to your model that results in dropping this index, you will need to modify the scaffolded DropIndex call to specify the IndexFk\_BlogId name.</span></span>

<span data-ttu-id="f1a3f-169">**Kullandıysanız ' seçeneği iki: bir başlangıç noktası olarak boş veritabanını kullan ' adım 3:**</span><span class="sxs-lookup"><span data-stu-id="f1a3f-169">**If you used ‘Option Two: Use empty database as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="f1a3f-170">Geçişleri dizinleri ve yanlış adları kullanarak yabancı anahtar kısıtlamalarını dener (yani, boş bir veritabanı için geri alma olduğu gibi) ilk geçiş aşağı yöntemi yerel veritabanınızda çalıştırılmaya çalışılırken başarısız olabilir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-170">Trying to run the Down method of the initial migration (that is, reverting to an empty database) against your local database may fail because Migrations will try to drop indexes and foreign key constraints using the incorrect names.</span></span> <span data-ttu-id="f1a3f-171">Diğer veritabanlarının ilk geçiş yukarı yöntemi kullanarak sıfırdan oluşturulacağından bu yalnızca yerel veritabanınızı etkiler.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-171">This will only affect your local database since other databases will be created from scratch using the Up method of the initial migration.</span></span>
    <span data-ttu-id="f1a3f-172">Var olan yerel veritabanınızı boş bir duruma düşürmek istiyorsanız bunu el ile veritabanını silmek veya tüm tabloları bırakarak yapmak oldukça kolaydır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-172">If you want to downgrade your existing local database to an empty state it is easiest to do this manually, either by dropping the database or dropping all the tables.</span></span> <span data-ttu-id="f1a3f-173">Varsayılan adlarla tüm veritabanı nesnelerinin oluşturulması bu ilk Sürüm Düşürme sonra bu nedenle bu sorunu kendisi yeniden sunacaktır değil.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-173">After this initial downgrade all database objects will be recreated with the default names, so this issue will not present itself again.</span></span>
-   <span data-ttu-id="f1a3f-174">Modelinize ileride yapılacak değişikliklerin değiştirmek veya farklı şekilde adlandırılmış veritabanı nesnelerinden birine bırakarak gerektiriyorsa, varsayılan adları eşleşmeyecektir olduğundan bu var olan yerel veritabanınızda – çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-174">If future changes in your model require changing or dropping one of the database objects that is named differently, this will not work against your existing local database – since the names won’t match the defaults.</span></span> <span data-ttu-id="f1a3f-175">Ancak, geçişleri tarafından seçmiş varsayılan adları kullanmış olduğundan, 'sıfırdan' oluşturulan veritabanlarına karşı çalışır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-175">However, it will work against databases that were created ‘from scratch’ since they will have used the default names chosen by Migrations.</span></span>
    <span data-ttu-id="f1a3f-176">Ya da bu değişiklikleri el ile yerel mevcut veritabanınızı yapmak veya diğer makinelere olacak şekilde veritabanınızı – sıfırdan yeniden geçişleri depolamayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-176">You could either make these changes manually on your local existing database, or consider having Migrations recreate your database from scratch – as it will on other machines.</span></span>
-   <span data-ttu-id="f1a3f-177">İlk geçişinizi yukarı yöntemi kullanılarak oluşturulan veritabanları dizinler için hesaplanan varsayılan adlar beri yerel veritabanından biraz farklı olabilir ve yabancı anahtar kısıtlamalarını kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-177">Databases created using the Up method of your initial migration may differ slightly from the local database since the calculated default names for indexes and foreign key constraints will be used.</span></span> <span data-ttu-id="f1a3f-178">Ayrıca ek dizinler bitirebilirsiniz gibi geçişleri dizinleri yabancı anahtar sütunlarına varsayılan olarak oluşturacaktır – bu durumda, özgün yerel veritabanınızı olmuş olabilir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-178">You may also end up with extra indexes as Migrations will create indexes on foreign key columns by default – this may not have been the case in your original local database.</span></span>

### <a name="not-all-database-objects-are-represented-in-the-model"></a><span data-ttu-id="f1a3f-179">Tüm veritabanı nesneleri modelinde temsil edilir</span><span class="sxs-lookup"><span data-stu-id="f1a3f-179">Not all database objects are represented in the model</span></span>

<span data-ttu-id="f1a3f-180">Modelinizin bir parçası olmayan veritabanı nesneleri tarafından geçişleri işlenmedi.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-180">Database objects that are not part of your model will not be handled by Migrations.</span></span> <span data-ttu-id="f1a3f-181">Bu görünümler, saklı yordamlar, izinler, model, ek dizinleri vb. parçası olmayan tablolar içerebilir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-181">This can include views, stored procedures, permissions, tables that are not part of your model, additional indexes, etc.</span></span>

<span data-ttu-id="f1a3f-182">Bu durumun farkında olması gerektiğinde bazı örnekleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f1a3f-182">Here are some examples of when you need to be aware of this:</span></span>

-   <span data-ttu-id="f1a3f-183">Seçenek bağımsız olarak, modelinize ileride yapılacak değişikliklerin değiştirme ya da geçişler bu değişiklikleri yapmak için oynatacaklarını bilmez bu ek nesneleri bırakarak kullanmanız gerekiyorsa 'Adım 3' olarak seçtiniz.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-183">Regardless of the option you chose in ‘Step 3’, if future changes in your model require changing or dropping these additional objects Migrations will not know to make these changes.</span></span> <span data-ttu-id="f1a3f-184">Örneğin, ek dizin içeren bir sütun sürüklerseniz, dizini silmek için geçişler bilmez.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-184">For example, if you drop a column that has an additional index on it, Migrations will not know to drop the index.</span></span> <span data-ttu-id="f1a3f-185">İskele kurulmuş geçişi bu el ile eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-185">You will need to manually add this to the scaffolded Migration.</span></span>
-   <span data-ttu-id="f1a3f-186">Kullandıysanız ' seçeneği iki: bir başlangıç noktası olarak boş veritabanını kullan ', bu ek nesneleri ilk geçişinizi yukarı yöntemi tarafından oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-186">If you used ‘Option Two: Use empty database as a starting point’, these additional objects will not be created by the Up method of your initial migration.</span></span>
    <span data-ttu-id="f1a3f-187">Yukarı değiştirebilir ve istediğiniz yöntemleri bu ek nesneleri, halletmeniz için.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-187">You can modify the Up and Down methods to take care of these additional objects if you wish.</span></span> <span data-ttu-id="f1a3f-188">Geçişleri API'sindeki – – görünümleri gibi yerel olarak desteklenmeyen nesneler için kullanabileceğiniz [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) oluşturma bunları bırakma için ham SQL çalıştırmak için yöntemi.</span><span class="sxs-lookup"><span data-stu-id="f1a3f-188">For objects that are not natively supported in the Migrations API – such as views – you can use the [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) method to run raw SQL to create/drop them.</span></span>
