---
title: Var olan bir veritabanıyla Code First Migrations-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
ms.openlocfilehash: eb7948eafb1322cabcf69b47bd5411f762fe8498
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78418995"
---
# <a name="code-first-migrations-with-an-existing-database"></a><span data-ttu-id="1ff48-102">Mevcut bir veritabanıyla Code First Migrations</span><span class="sxs-lookup"><span data-stu-id="1ff48-102">Code First Migrations with an existing database</span></span>
> [!NOTE]
> <span data-ttu-id="1ff48-103">**EF 4.3 yalnızca** bu sayfada açıklanan özellikler, API 'ler, vb. Entity Framework 4,1 ' de tanıtılmıştı.</span><span class="sxs-lookup"><span data-stu-id="1ff48-103">**EF4.3 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 4.1.</span></span> <span data-ttu-id="1ff48-104">Önceki bir sürümü kullanıyorsanız, bilgilerin bazıları veya tümü uygulanmaz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-104">If you are using an earlier version, some or all of the information does not apply.</span></span>

<span data-ttu-id="1ff48-105">Bu makalede, Entity Framework tarafından oluşturulmamış mevcut bir veritabanıyla Code First Migrations kullanımı ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-105">This article covers using Code First Migrations with an existing database, one that wasn’t created by Entity Framework.</span></span>

> [!NOTE]
> <span data-ttu-id="1ff48-106">Bu makalede temel senaryolarda Code First Migrations kullanmayı bildiğiniz varsayılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-106">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="1ff48-107">Bunu yapmazsanız devam etmeden önce [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) okumanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-107">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="screencasts"></a><span data-ttu-id="1ff48-108">Tasarlandı</span><span class="sxs-lookup"><span data-stu-id="1ff48-108">Screencasts</span></span>

<span data-ttu-id="1ff48-109">Bu makaleyi okuduğunuzdan bir ekran koruyucu izlemeyi tercih ediyorsanız, aşağıdaki iki video bu makaleyle aynı içeriği kapsar.</span><span class="sxs-lookup"><span data-stu-id="1ff48-109">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="1ff48-110">Video One: "geçişler-,"</span><span class="sxs-lookup"><span data-stu-id="1ff48-110">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="1ff48-111">[Bu ekran kaydı](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) , geçişlerin, model değişikliklerini algılamak için model hakkındaki bilgileri nasıl izlediğini ve kullandığını ele alır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-111">[This screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---existing-databases"></a><span data-ttu-id="1ff48-112">Video Iki: "geçişler-var olan veritabanları"</span><span class="sxs-lookup"><span data-stu-id="1ff48-112">Video Two: "Migrations - Existing Databases"</span></span>

<span data-ttu-id="1ff48-113">Önceki videodaki kavramlar üzerinde oluşturma, [Bu ekran kaydı](https://channel9.msdn.com/blogs/ef/migrations-existing-databases) , var olan bir veritabanıyla geçişleri etkinleştirme ve kullanma konularını ele alır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-113">Building on the concepts from the previous video, [this screencast](https://channel9.msdn.com/blogs/ef/migrations-existing-databases) covers how to enable and use migrations with an existing database.</span></span>

## <a name="step-1-create-a-model"></a><span data-ttu-id="1ff48-114">1\. Adım: model oluşturma</span><span class="sxs-lookup"><span data-stu-id="1ff48-114">Step 1: Create a model</span></span>

<span data-ttu-id="1ff48-115">İlk adımınız, var olan veritabanınızı hedefleyen Code First bir model oluşturmak olacaktır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-115">Your first step will be to create a Code First model that targets your existing database.</span></span> <span data-ttu-id="1ff48-116">[Var olan bir veritabanına Code First](~/ef6/modeling/code-first/workflows/existing-database.md) , bunun nasıl yapılacağı hakkında ayrıntılı yönergeler sağlar.</span><span class="sxs-lookup"><span data-stu-id="1ff48-116">The [Code First to an Existing Database](~/ef6/modeling/code-first/workflows/existing-database.md) topic provides detailed guidance on how to do this.</span></span>

>[!NOTE]
> <span data-ttu-id="1ff48-117">Modelinizde veritabanı şemasında değişiklik yapılmasını gerektiren değişiklikler yapmadan önce bu konudaki adımların geri kalanını izlemeniz önemlidir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-117">It is important to follow the rest of the steps in this topic before making any changes to your model that would require changes to the database schema.</span></span> <span data-ttu-id="1ff48-118">Aşağıdaki adımlar, modelin veritabanı şeması ile eşitlenmiş olmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-118">The following steps require the model to be in-sync with the database schema.</span></span>

## <a name="step-2-enable-migrations"></a><span data-ttu-id="1ff48-119">2\. Adım: geçişleri etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="1ff48-119">Step 2: Enable Migrations</span></span>

<span data-ttu-id="1ff48-120">Sonraki adım, geçişleri etkinleştirmektir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-120">The next step is to enable migrations.</span></span> <span data-ttu-id="1ff48-121">Bunu, Paket Yöneticisi konsolundaki **geçişi etkinleştir** komutunu çalıştırarak yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-121">You can do this by running the **Enable-Migrations** command in Package Manager Console.</span></span>

<span data-ttu-id="1ff48-122">Bu komut, çözümünüzde geçişler adlı bir klasör oluşturur ve bunun içinde yapılandırma adlı tek bir sınıf yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-122">This command will create a folder in your solution called Migrations, and put a single class inside it called Configuration.</span></span> <span data-ttu-id="1ff48-123">Yapılandırma sınıfı, uygulamanız için geçişleri yapılandırdığınız yerdir, [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) konusunda daha fazla bilgi edinebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-123">The Configuration class is where you configure migrations for your application, you can find out more about it in the [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) topic.</span></span>

## <a name="step-3-add-an-initial-migration"></a><span data-ttu-id="1ff48-124">3\. Adım: ilk geçiş ekleme</span><span class="sxs-lookup"><span data-stu-id="1ff48-124">Step 3: Add an initial migration</span></span>

<span data-ttu-id="1ff48-125">Geçişler oluşturulduktan ve yerel veritabanına uygulandıktan sonra, bu değişiklikleri diğer veritabanlarına da uygulamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-125">Once migrations have been created and applied to the local database you may also want to apply these changes to other databases.</span></span> <span data-ttu-id="1ff48-126">Örneğin, yerel veritabanınız bir test veritabanı olabilir ve son olarak, değişiklikleri bir üretim veritabanına ve/veya diğer geliştiriciler test veritabanlarına de uygulamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-126">For example, your local database may be a test database and you may ultimately want to also apply the changes to a production database and/or other developers test databases.</span></span> <span data-ttu-id="1ff48-127">Bu adım için iki seçenek bulunur ve sizin seçmeniz gereken diğer veritabanlarının şemasının boş olup olmadığı veya şu anda yerel veritabanının şemasıyla eşleşip eşleşmediğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-127">There are two options for this step and the one you should pick depends whether or not the schema of any other databases is empty or currently matches the schema of the local database.</span></span>

-   <span data-ttu-id="1ff48-128">**Seçenek One: varolan şemayı başlangıç noktası olarak kullanın.**</span><span class="sxs-lookup"><span data-stu-id="1ff48-128">**Option One: Use existing schema as starting point.**</span></span> <span data-ttu-id="1ff48-129">Bu yaklaşımı, daha sonra geçiş yapılacak diğer veritabanları, yerel veritabanınız ile aynı şemaya sahip olacağı durumlarda kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-129">You should use this approach when other databases that migrations will be applied to in the future will have the same schema as your local database currently has.</span></span> <span data-ttu-id="1ff48-130">Örneğin, yerel test veritabanınız Şu anda üretim veritabanınızın v1 ile eşleşiyorsa bunu kullanabilir ve daha sonra üretim veritabanınızı v2 'ye güncelleştirmek için bu geçişleri uygularsınız.</span><span class="sxs-lookup"><span data-stu-id="1ff48-130">For example, you might use this if your local test database currently matches v1 of your production database and you will later apply these migrations to update your production database to v2.</span></span>
-   <span data-ttu-id="1ff48-131">**Iki seçenek: boş veritabanını başlangıç noktası olarak kullanın.**</span><span class="sxs-lookup"><span data-stu-id="1ff48-131">**Option Two: Use empty database as starting point.**</span></span> <span data-ttu-id="1ff48-132">Bu yaklaşımı, geçiş için daha sonra uygulanacak diğer veritabanları boş olduğunda (veya henüz yoksa) kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-132">You should use this approach when other databases that migrations will be applied to in the future are empty (or do not exist yet).</span></span> <span data-ttu-id="1ff48-133">Örneğin, bir test veritabanını kullanarak uygulamanızı geliştirmeye başladıysanız ancak geçişleri kullanmadan, daha sonra bir üretim veritabanını sıfırdan oluşturmak istiyorsanız bu işlemi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-133">For example, you might use this if you started developing your application using a test database but without using migrations and you will later want to create a production database from scratch.</span></span>

### <a name="option-one-use-existing-schema-as-a-starting-point"></a><span data-ttu-id="1ff48-134">Seçenek One: varolan şemayı başlangıç noktası olarak kullanma</span><span class="sxs-lookup"><span data-stu-id="1ff48-134">Option One: Use existing schema as a starting point</span></span>

<span data-ttu-id="1ff48-135">Code First Migrations, modeldeki değişiklikleri algılamak için en son geçişte depolanan modelin anlık görüntüsünü kullanır (Bu, ilgili ayrıntılı bilgileri [Takım ortamlarında Code First Migrations](~/ef6/modeling/code-first/migrations/teams.md)bulabilirsiniz).</span><span class="sxs-lookup"><span data-stu-id="1ff48-135">Code First Migrations uses a snapshot of the model stored in the most recent migration to detect changes to the model (you can find detailed information about this in [Code First Migrations in Team Environments](~/ef6/modeling/code-first/migrations/teams.md)).</span></span> <span data-ttu-id="1ff48-136">Veritabanlarının zaten geçerli modelin şemasına sahip olduğunu varsaydığımızdan, anlık görüntü olarak geçerli modele sahip boş bir (Hayır-op) geçişi oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="1ff48-136">Since we are going to assume that databases already have the schema of the current model, we will generate an empty (no-op) migration that has the current model as a snapshot.</span></span>

1.  <span data-ttu-id="1ff48-137">Paket Yöneticisi konsolundaki **Add-Migration ınitialcreate – ıgnorechanges** komutunu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="1ff48-137">Run the **Add-Migration InitialCreate –IgnoreChanges** command in Package Manager Console.</span></span> <span data-ttu-id="1ff48-138">Bu, geçerli modelle anlık görüntü olarak boş bir geçiş oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1ff48-138">This creates an empty migration with the current model as a snapshot.</span></span>
2.  <span data-ttu-id="1ff48-139">Package Manager konsolunda **Update-Database** komutunu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="1ff48-139">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="1ff48-140">Bu, ınitialcreate geçişini veritabanına uygular.</span><span class="sxs-lookup"><span data-stu-id="1ff48-140">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="1ff48-141">Gerçek geçiş hiçbir değişiklik içermediğinden, bu geçişin zaten uygulandığını belirten \_\_MigrationsHistory tablosuna bir satır ekler.</span><span class="sxs-lookup"><span data-stu-id="1ff48-141">Since the actual migration doesn’t contain any changes, it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>

### <a name="option-two-use-empty-database-as-a-starting-point"></a><span data-ttu-id="1ff48-142">Iki seçenek: boş veritabanını başlangıç noktası olarak kullanma</span><span class="sxs-lookup"><span data-stu-id="1ff48-142">Option Two: Use empty database as a starting point</span></span>

<span data-ttu-id="1ff48-143">Bu senaryoda, yerel veritabanımızda zaten mevcut olan tablolar da dahil olmak üzere tüm veritabanını sıfırdan oluşturabilmeniz için geçişlere ihtiyacımız var.</span><span class="sxs-lookup"><span data-stu-id="1ff48-143">In this scenario we need Migrations to be able to create the entire database from scratch – including the tables that are already present in our local database.</span></span> <span data-ttu-id="1ff48-144">Mevcut şemayı oluşturma mantığını içeren bir ınitialcreate geçişi oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="1ff48-144">We’re going to generate an InitialCreate migration that includes logic to create the existing schema.</span></span> <span data-ttu-id="1ff48-145">Daha sonra var olan veritabanımızın bu geçiş zaten uygulanmış gibi görünmesini sağlayacağız.</span><span class="sxs-lookup"><span data-stu-id="1ff48-145">We’ll then make our existing database look like this migration has already been applied.</span></span>

1.  <span data-ttu-id="1ff48-146">Paket Yöneticisi konsolundaki **Add-Migration ınitialcreate** komutunu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="1ff48-146">Run the **Add-Migration InitialCreate** command in Package Manager Console.</span></span> <span data-ttu-id="1ff48-147">Bu, varolan şemayı oluşturmak için bir geçiş oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1ff48-147">This creates a migration to create the existing schema.</span></span>
2.  <span data-ttu-id="1ff48-148">Yeni oluşturulan geçişin up yöntemindeki tüm kodu açıklama.</span><span class="sxs-lookup"><span data-stu-id="1ff48-148">Comment out all code in the Up method of the newly created migration.</span></span> <span data-ttu-id="1ff48-149">Bu, daha önce var olan tüm tabloları yeniden oluşturmaya gerek kalmadan yerel veritabanına geçişi ' uygulamamıza izin verir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-149">This will allow us to ‘apply’ the migration to the local database without trying to recreate all the tables etc. that already exist.</span></span>
3.  <span data-ttu-id="1ff48-150">Package Manager konsolunda **Update-Database** komutunu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="1ff48-150">Run the **Update-Database** command in Package Manager Console.</span></span> <span data-ttu-id="1ff48-151">Bu, ınitialcreate geçişini veritabanına uygular.</span><span class="sxs-lookup"><span data-stu-id="1ff48-151">This will apply the InitialCreate migration to the database.</span></span> <span data-ttu-id="1ff48-152">Gerçek geçiş herhangi bir değişiklik içermediğinden (bunları geçici olarak belirlediğimiz için), bu geçişin zaten uygulandığını belirten \_\_MigrationsHistory tablosuna bir satır ekler.</span><span class="sxs-lookup"><span data-stu-id="1ff48-152">Since the actual migration doesn’t contain any changes (because we temporarily commented them out), it will simply add a row to the \_\_MigrationsHistory table indicating that this migration has already been applied.</span></span>
4.  <span data-ttu-id="1ff48-153">Up yöntemindeki kodun açıklamasını kaldırın.</span><span class="sxs-lookup"><span data-stu-id="1ff48-153">Un-comment the code in the Up method.</span></span> <span data-ttu-id="1ff48-154">Bu, geçiş gelecekteki veritabanlarına uygulandığında, yerel veritabanında zaten var olan şemanın geçişler tarafından oluşturulacağı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-154">This means that when this migration is applied to future databases, the schema that already existed in the local database will be created by migrations.</span></span>

## <a name="things-to-be-aware-of"></a><span data-ttu-id="1ff48-155">Dikkat edilmesi gerekenler</span><span class="sxs-lookup"><span data-stu-id="1ff48-155">Things to be aware of</span></span>

<span data-ttu-id="1ff48-156">Mevcut bir veritabanına yönelik geçişleri kullanırken bilmeniz gereken birkaç nokta vardır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-156">There are a few things you need to be aware of when using Migrations against an existing database.</span></span>

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a><span data-ttu-id="1ff48-157">Varsayılan/hesaplanan adlar varolan şemayla eşleşmeyebilir</span><span class="sxs-lookup"><span data-stu-id="1ff48-157">Default/calculated names may not match existing schema</span></span>

<span data-ttu-id="1ff48-158">Geçişler, bir geçişleri yapılandırırken sütun ve tablo adlarını açıkça belirler.</span><span class="sxs-lookup"><span data-stu-id="1ff48-158">Migrations explicitly specifies names for columns and tables when it scaffolds a migrations.</span></span> <span data-ttu-id="1ff48-159">Ancak, geçişler uygulanırken geçiş için varsayılan bir adı hesaplayan diğer veritabanı nesneleri vardır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-159">However, there are other database objects that Migrations calculates a default name for when applying the migrations.</span></span> <span data-ttu-id="1ff48-160">Bu dizinler ve yabancı anahtar kısıtlamalarını içerir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-160">This includes indexes and foreign key constraints.</span></span> <span data-ttu-id="1ff48-161">Mevcut bir şemayı hedeflerken, bu hesaplanan adlar veritabanınızda gerçekten mevcut olan ile eşleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-161">When targeting an existing schema, these calculated names may not match what actually exists in your database.</span></span>

<span data-ttu-id="1ff48-162">Bunun ne zaman farkında olmanız gerektiği hakkında bazı örnekler aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="1ff48-162">Here are some examples of when you need to be aware of this:</span></span>

<span data-ttu-id="1ff48-163">**' Seçenek birini kullandıysanız, adım 3 ' ten bir başlangıç noktası olarak mevcut şemayı kullanın ':**</span><span class="sxs-lookup"><span data-stu-id="1ff48-163">**If you used ‘Option One: Use existing schema as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="1ff48-164">Modelinizdeki gelecekteki değişiklikler farklı şekilde adlandırılan veritabanı nesnelerinden birinin değiştirilmesini veya bırakılmasını gerektiriyorsa, doğru adı belirtmek için yapı iskelesi geçişini değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-164">If future changes in your model require changing or dropping one of the database objects that is named differently, you will need to modify the scaffolded migration to specify the correct name.</span></span> <span data-ttu-id="1ff48-165">Geçişler API 'Leri, bunu yapmanıza olanak sağlayan isteğe bağlı bir ad parametresine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-165">The Migrations APIs have an optional Name parameter that allows you to do this.</span></span>
    <span data-ttu-id="1ff48-166">Örneğin, var olan şemanızın IndexFk\_blogID adlı bir dizin içeren bir blogID yabancı anahtar sütunu olan bir post tablosu olabilir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-166">For example, your existing schema may have a Post table with a BlogId foreign key column that has an index named IndexFk\_BlogId.</span></span> <span data-ttu-id="1ff48-167">Ancak, varsayılan olarak geçişler bu dizinin x\_blogID olarak adlandırıldığını bekler.</span><span class="sxs-lookup"><span data-stu-id="1ff48-167">However, by default Migrations would expect this index to be named IX\_BlogId.</span></span> <span data-ttu-id="1ff48-168">Modelinizde bu dizini bırakmaya neden olan bir değişiklik yaparsanız, IndexFk\_blogID adını belirtmek için scafkatlanmış DropIndex çağrısını değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-168">If you make a change to your model that results in dropping this index, you will need to modify the scaffolded DropIndex call to specify the IndexFk\_BlogId name.</span></span>

<span data-ttu-id="1ff48-169">**' Seçeneği Iki ' i kullandıysanız, adım 3 ' ten bir başlangıç noktası olarak boş veritabanını kullan ':**</span><span class="sxs-lookup"><span data-stu-id="1ff48-169">**If you used ‘Option Two: Use empty database as a starting point’ from Step 3:**</span></span>

-   <span data-ttu-id="1ff48-170">Geçişler, hatalı adları kullanarak dizin ve yabancı anahtar kısıtlamalarını bırakmaya çalışacağından, ilk geçişin (yani boş bir veritabanına geri döndürülmesi), yerel veritabanınıza karşı çalışma yöntemini çalıştırmaya çalışmak başarısız olabilir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-170">Trying to run the Down method of the initial migration (that is, reverting to an empty database) against your local database may fail because Migrations will try to drop indexes and foreign key constraints using the incorrect names.</span></span> <span data-ttu-id="1ff48-171">Bu, ilk geçişin up yöntemi kullanılarak diğer veritabanları sıfırdan oluşturulduğundan, yalnızca yerel veritabanınızı etkiler.</span><span class="sxs-lookup"><span data-stu-id="1ff48-171">This will only affect your local database since other databases will be created from scratch using the Up method of the initial migration.</span></span>
    <span data-ttu-id="1ff48-172">Mevcut yerel veritabanınızı boş bir duruma düşürmek isterseniz, veritabanını bırakarak veya tüm tabloları bırakarak bunu el ile yapmak en kolay yoldur.</span><span class="sxs-lookup"><span data-stu-id="1ff48-172">If you want to downgrade your existing local database to an empty state it is easiest to do this manually, either by dropping the database or dropping all the tables.</span></span> <span data-ttu-id="1ff48-173">Bu ilk kez düşürme sonrasında tüm veritabanı nesneleri varsayılan adlarla yeniden oluşturulacaktır, bu nedenle bu sorun kendisini tekrar sunmaz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-173">After this initial downgrade all database objects will be recreated with the default names, so this issue will not present itself again.</span></span>
-   <span data-ttu-id="1ff48-174">Modelinizdeki gelecekteki değişiklikler farklı şekilde adlandırılan veritabanı nesnelerinden birinin değiştirilmesini veya bırakılmasını gerektiriyorsa, bu adlar varsayılanlar ile eşleşmediğinden, mevcut yerel veritabanınıza karşı çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-174">If future changes in your model require changing or dropping one of the database objects that is named differently, this will not work against your existing local database – since the names won’t match the defaults.</span></span> <span data-ttu-id="1ff48-175">Ancak, geçişler tarafından seçilen varsayılan adları kullandıklarından ' sıfırdan ' ' sıfırdan ' oluşturulan veritabanlarına karşı çalışır.</span><span class="sxs-lookup"><span data-stu-id="1ff48-175">However, it will work against databases that were created ‘from scratch’ since they will have used the default names chosen by Migrations.</span></span>
    <span data-ttu-id="1ff48-176">Bu değişiklikleri yerel var olan veritabanınızda el ile yapabilir veya geçiş yapmayı, diğer makinelerde olduğu gibi, veritabanınızı sıfırdan yeniden oluşturmasını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-176">You could either make these changes manually on your local existing database, or consider having Migrations recreate your database from scratch – as it will on other machines.</span></span>
-   <span data-ttu-id="1ff48-177">İlk geçişinizin up yöntemi kullanılarak oluşturulan veritabanları, dizinler ve yabancı anahtar kısıtlamaları için hesaplanmış varsayılan adlar kullanılacak olduğundan, yerel veritabanından biraz farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-177">Databases created using the Up method of your initial migration may differ slightly from the local database since the calculated default names for indexes and foreign key constraints will be used.</span></span> <span data-ttu-id="1ff48-178">Geçiş, yabancı anahtar sütunlarında varsayılan olarak dizin oluşturacak şekilde ek dizinler de alabilir; bu durum özgün yerel veritabanınızda bu durum olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-178">You may also end up with extra indexes as Migrations will create indexes on foreign key columns by default – this may not have been the case in your original local database.</span></span>

### <a name="not-all-database-objects-are-represented-in-the-model"></a><span data-ttu-id="1ff48-179">Tüm veritabanı nesneleri modelde temsil edilmez</span><span class="sxs-lookup"><span data-stu-id="1ff48-179">Not all database objects are represented in the model</span></span>

<span data-ttu-id="1ff48-180">Modelinize dahil olmayan veritabanı nesneleri geçişler tarafından işlenmeyecektir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-180">Database objects that are not part of your model will not be handled by Migrations.</span></span> <span data-ttu-id="1ff48-181">Bu, görünümleri, saklı yordamları, izinleri, modelinizin bir parçası olmayan tabloları, ek dizinleri vb. içerebilir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-181">This can include views, stored procedures, permissions, tables that are not part of your model, additional indexes, etc.</span></span>

<span data-ttu-id="1ff48-182">Bunun ne zaman farkında olmanız gerektiği hakkında bazı örnekler aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="1ff48-182">Here are some examples of when you need to be aware of this:</span></span>

-   <span data-ttu-id="1ff48-183">' Adım 3 ' te seçtiğiniz seçenekten bağımsız olarak, modelinizdeki gelecekteki değişiklikler bu ek nesnelerin değiştirilmesini veya bırakılmasını gerektiriyorsa, bu değişiklikleri yapmak için bu değişiklikleri bilmez.</span><span class="sxs-lookup"><span data-stu-id="1ff48-183">Regardless of the option you chose in ‘Step 3’, if future changes in your model require changing or dropping these additional objects Migrations will not know to make these changes.</span></span> <span data-ttu-id="1ff48-184">Örneğin, üzerinde ek bir dizin olan bir sütunu bırakırsanız, geçişler dizini bırakmayı bilmez.</span><span class="sxs-lookup"><span data-stu-id="1ff48-184">For example, if you drop a column that has an additional index on it, Migrations will not know to drop the index.</span></span> <span data-ttu-id="1ff48-185">Bunu, yapı iskelesi geçişine el ile eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="1ff48-185">You will need to manually add this to the scaffolded Migration.</span></span>
-   <span data-ttu-id="1ff48-186">' Seçeneği Iki kez kullandıysanız, başlangıç noktası olarak boş veritabanını kullan ' ı kullandıysanız, bu ek nesneler ilk geçişinizin up yöntemi tarafından oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-186">If you used ‘Option Two: Use empty database as a starting point’, these additional objects will not be created by the Up method of your initial migration.</span></span>
    <span data-ttu-id="1ff48-187">İsterseniz, bu ek nesnelerle ilgilenmek için yukarı ve aşağı yöntemlerini değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-187">You can modify the Up and Down methods to take care of these additional objects if you wish.</span></span> <span data-ttu-id="1ff48-188">Geçişler API 'sinde, görünümler gibi yerel olarak desteklenmeyen nesneler için, [SQL](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) metodunu kullanarak ham SQL 'i oluşturabilir/bırakabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1ff48-188">For objects that are not natively supported in the Migrations API – such as views – you can use the [Sql](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) method to run raw SQL to create/drop them.</span></span>
