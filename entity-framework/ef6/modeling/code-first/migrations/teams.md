---
title: Takım ortamları - EF6 Code First geçişleri
author: divega
ms.date: 2016-10-23
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 42f52e63fd6cfc1f02d6a721594f4a161eea9a7b
ms.sourcegitcommit: dadee5905ada9ecdbae28363a682950383ce3e10
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/27/2018
ms.locfileid: "42997305"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="e6739-102">Takım ortamları Code First geçişleri</span><span class="sxs-lookup"><span data-stu-id="e6739-102">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="e6739-103">Bu makalede, temel senaryolarda Code First Migrations nasıl kullanılacağını varsayar.</span><span class="sxs-lookup"><span data-stu-id="e6739-103">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="e6739-104">Sizin sonra okumak ihtiyacınız olacak [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) devam etmeden önce.</span><span class="sxs-lookup"><span data-stu-id="e6739-104">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="e6739-105">Bir kahve, tüm bu makaleyi okumak gerekli</span><span class="sxs-lookup"><span data-stu-id="e6739-105">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="e6739-106">Ekip ortamlarında iki geliştiriciler kendi yerel kod temelinde geçişleri oluşturduğunuzda çoğunlukla geçişleri birleştirme etrafında sorunlardır.</span><span class="sxs-lookup"><span data-stu-id="e6739-106">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="e6739-107">Bunları çözmek için adımları oldukça basit olsa da, bunlar geçişleri nasıl çalıştığına ilişkin sağlam bir anlama sahip olmanızı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e6739-107">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="e6739-108">Lütfen yoksa yalnızca sonuna kadar İleri atlayabilirsiniz: başarılı olduğundan emin olmak için tüm makaleyi okumak için zaman ayırın.</span><span class="sxs-lookup"><span data-stu-id="e6739-108">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="e6739-109">Bazı genel yönergeleri</span><span class="sxs-lookup"><span data-stu-id="e6739-109">Some general guidelines</span></span>

<span data-ttu-id="e6739-110">Biz birden fazla geliştirici tarafından oluşturulan birleştirme geçişleri yönetmek nasıl ayrıntılı olarak incelemeden önce başarı için ayarlamak için bazı genel yönergeleri aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e6739-110">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="e6739-111">Her ekip üyesi, yerel geliştirme veritabanı olmalıdır</span><span class="sxs-lookup"><span data-stu-id="e6739-111">Each team member should have a local development database</span></span>

<span data-ttu-id="e6739-112">Geçişleri kullanır  **\_ \_MigrationsHistory** hangi geçişleri veritabanına uygulanmış depolamak üzere tablo.</span><span class="sxs-lookup"><span data-stu-id="e6739-112">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="e6739-113">Birden çok geliştirici aynı veritabanını hedeflediğinizden çalışırken farklı geçişler oluşturma varsa (ve bu nedenle paylaşma bir  **\_ \_MigrationsHistory** tablo) geçişleri gittiğini çok kafanız alın.</span><span class="sxs-lookup"><span data-stu-id="e6739-113">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="e6739-114">Elbette, geçişler oluşturan olmayan takım üyeleriniz varsa, bunları Geliştirme Merkezi veritabanını paylaşan sahip hiçbir sorun yoktur.</span><span class="sxs-lookup"><span data-stu-id="e6739-114">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="e6739-115">Otomatik geçişleri kaçının</span><span class="sxs-lookup"><span data-stu-id="e6739-115">Avoid automatic migrations</span></span>

<span data-ttu-id="e6739-116">Alt satır otomatik geçişleri başlangıçta takım ortamlarda iyi görünür ancak gerçekte yalnızca çalışmıyor değil.</span><span class="sxs-lookup"><span data-stu-id="e6739-116">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="e6739-117">Neden – okumaya devam edin, bilmek istiyorsunuz değilse, ardından, sonraki bölüme atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-117">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="e6739-118">Otomatik geçişleri kod dosyaları (kod tabanlı geçişler) oluşturmaya gerek kalmadan geçerli model eşleşecek şekilde güncelleştirildi, veritabanı şemasını sahip olmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6739-118">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="e6739-119">Yalnızca kimse tarafından kullanılmadı ve hiçbir zaman herhangi bir kod tabanlı geçişler oluşturulan otomatik geçişleri çok iyi bir ekip ortamında çalışır.</span><span class="sxs-lookup"><span data-stu-id="e6739-119">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="e6739-120">Sorun otomatik geçişleri sınırlıdır ve işlemlerinin sayısı işlemez – özellik/sütununu yeniden adlandırır, başka bir tabloya veri taşıma, vs. Bu senaryolar, düştüğünden işlemek için kod tabanlı geçişler oluşturmak (ve iskele kurulmuş kod düzenleme) otomatik geçişleri tarafından işlenen değişiklikleri arasında karma.</span><span class="sxs-lookup"><span data-stu-id="e6739-120">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="e6739-121">Bu, yakın üzerinde olanaksız kılar iki geliştiriciler geçişlerde iade ettiğinizde, değişiklikleri birleştirmek için.</span><span class="sxs-lookup"><span data-stu-id="e6739-121">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="e6739-122">Ekran kayıtları</span><span class="sxs-lookup"><span data-stu-id="e6739-122">Screencasts</span></span>

<span data-ttu-id="e6739-123">Bu makaleyi okuyun bir yayını daha yerine izleyin, bu makalede aynı içeriğe aşağıdaki iki video kapsar.</span><span class="sxs-lookup"><span data-stu-id="e6739-123">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="e6739-124">Bir video: "Başlık altında - geçişler"</span><span class="sxs-lookup"><span data-stu-id="e6739-124">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="e6739-125">[Bu yayını](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) geçişleri nasıl izlediği kapsar ve modeli hakkında bilgi modeli değişikliklerini algılamak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6739-125">[This screencast](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="e6739-126">Video iki: "Geçişler - takım ortamları"</span><span class="sxs-lookup"><span data-stu-id="e6739-126">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="e6739-127">Önceki video kavramları güncelleştirmelerle [bu yayını](http://channel9.msdn.com/blogs/ef/migrations-team-environments) takım ortamını ve bunları çözmek nasıl ortaya çıkan sorunları ele alır.</span><span class="sxs-lookup"><span data-stu-id="e6739-127">Building on the concepts from the previous video, [this screencast](http://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="e6739-128">Geçişleri nasıl çalıştığını anlama</span><span class="sxs-lookup"><span data-stu-id="e6739-128">Understanding how migrations works</span></span>

<span data-ttu-id="e6739-129">Anahtar başarıyla bir ekip ortamında migrations'ı kullanma, temel bir geçişi nasıl izlediği anlama ve modeli değişikliklerini algılamak için modelle ilgili bilgiler kullanır.</span><span class="sxs-lookup"><span data-stu-id="e6739-129">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="e6739-130">İlk geçiş</span><span class="sxs-lookup"><span data-stu-id="e6739-130">The first migration</span></span>

<span data-ttu-id="e6739-131">İlk geçiş projenizi için eklediğinizde, aşağıdaki gibi çalıştırın **Ekle geçiş ilk** Paket Yöneticisi konsolunda.</span><span class="sxs-lookup"><span data-stu-id="e6739-131">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="e6739-132">Bu komut gerçekleştiren üst düzey adımlar aşağıda gösterilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-132">The high level steps that this command performs are pictured below.</span></span>

![FirstMigration](~/ef6/media/firstmigration.png)

<span data-ttu-id="e6739-134">Geçerli model kodunuzdan (1) olarak hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="e6739-134">The current model is calculated from your code (1).</span></span> <span data-ttu-id="e6739-135">Gerekli veritabanı nesnelerini ardından model farkları (2) hesaplanan – yalnızca kullanır, bu ilk geçiş modeli olduğundan, karşılaştırma için boş bir model farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="e6739-135">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="e6739-136">Visual Studio çözümünüzü (4) daha sonra eklenen gerekli geçiş kodu (3) derlemek için kod Oluşturucu için gerekli değişiklikleri geçirilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-136">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="e6739-137">Ana kod dosyasında depolanan gerçek geçiş kodu yanı sıra, geçişleri de bazı ek arka plan kod dosyaları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e6739-137">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="e6739-138">Bu dosyalar, geçişleri tarafından kullanılan meta verilerdir ve düzenleme bir şey değildir.</span><span class="sxs-lookup"><span data-stu-id="e6739-138">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="e6739-139">Bu dosyalar geçiş oluşturulduğu sırada model anlık görüntüsünü içeren bir kaynak dosyası (.resx) biridir.</span><span class="sxs-lookup"><span data-stu-id="e6739-139">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="e6739-140">Sonraki adımda bunu nasıl kullanıldığını görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="e6739-140">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="e6739-141">Bu noktada, büyük olasılıkla çalıştıracağınız **veritabanını Güncelleştir** değişikliklerinizi veritabanına uygulayın ve ardından uygulamanızın diğer alanlar'ı uygulama hakkında.</span><span class="sxs-lookup"><span data-stu-id="e6739-141">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="e6739-142">Sonraki geçişleri</span><span class="sxs-lookup"><span data-stu-id="e6739-142">Subsequent migrations</span></span>

<span data-ttu-id="e6739-143">Daha sonra geri dönün ve modelinize bazı değişiklikler yapmanız – örneğimizde ekleyeceğiz bir **Url** özelliğini **Blog**.</span><span class="sxs-lookup"><span data-stu-id="e6739-143">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="e6739-144">Bir komut gibi ardından vermek **Ekle geçiş AddUrl** karşılık gelen veritabanı uygulamak için bir geçiş iskelesini değişir.</span><span class="sxs-lookup"><span data-stu-id="e6739-144">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="e6739-145">Bu komut gerçekleştiren üst düzey adımlar aşağıda gösterilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-145">The high level steps that this command performs are pictured below.</span></span>

![SecondMigration](~/ef6/media/secondmigration.png)

<span data-ttu-id="e6739-147">Aynı geçen seferki gibi geçerli model koddan (1) olarak hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="e6739-147">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="e6739-148">Ancak bu kez var. mevcut geçişleri önceki modelde en son geçiş (2) alınır böylece</span><span class="sxs-lookup"><span data-stu-id="e6739-148">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="e6739-149">Diff (3) gerekli veritabanı değişikliklerini bulmak için bu iki modeli olan ve işlemini'ı önceki gibi tamamlar.</span><span class="sxs-lookup"><span data-stu-id="e6739-149">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="e6739-150">Aynı işlemi projeye eklemek daha tüm geçişler için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e6739-150">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="e6739-151">Neden model anlık görüntü rahatsız?</span><span class="sxs-lookup"><span data-stu-id="e6739-151">Why bother with the model snapshot?</span></span>

<span data-ttu-id="e6739-152">Neden EF modeli anlık görüntü ile – rahatsız değil yalnızca görünüm neden, veritabanını merak ediyor olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-152">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="e6739-153">Bu durumda, okumaya devam edin.</span><span class="sxs-lookup"><span data-stu-id="e6739-153">If so, read on.</span></span> <span data-ttu-id="e6739-154">Ardından ilgilenen değilseniz, bu bölümü atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-154">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="e6739-155">Pek çok EF modeli anlık görüntü etrafında tutar vardır:</span><span class="sxs-lookup"><span data-stu-id="e6739-155">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="e6739-156">EF modeli kayma veritabanına sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6739-156">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="e6739-157">Bu değişiklik veritabanına doğrudan yapılamaz veya değişiklik yapmak için geçişler iskele kurulan kodu değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-157">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="e6739-158">Bu uygulamada örnekleri birkaç şunlardır:</span><span class="sxs-lookup"><span data-stu-id="e6739-158">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="e6739-159">Bir eklenen ve güncelleştirilen bir veya daha fazla tablolara sütun eklemek istediğiniz, ancak bu sütunların EF modele dahil etmek istemediğiniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-159">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="e6739-160">Geçişler veritabanını görünüyorsa bir geçiş iskele kurulmuş her zaman bu sütunları kaldırın sürekli isteriz.</span><span class="sxs-lookup"><span data-stu-id="e6739-160">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="e6739-161">Model anlık görüntüyü kullanarak EF her zaman sadece modeline yasal değişiklikleri algılar.</span><span class="sxs-lookup"><span data-stu-id="e6739-161">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="e6739-162">Güncelleştirmeler için bazı günlük dahil etmek için kullanılan bir saklı yordam gövde metni değiştirmek istediğinizde.</span><span class="sxs-lookup"><span data-stu-id="e6739-162">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="e6739-163">Bu saklı yordamı, veritabanı geçişleri görünüyorsa, sürekli olarak deneyin ve geri EF bekliyor tanımına sıfırlama.</span><span class="sxs-lookup"><span data-stu-id="e6739-163">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="e6739-164">Modeli anlık görüntü kullanarak EF yalnızca şimdiye kadar EF modeli yordamda şeklini değiştirdiğinizde saklı yordamı değiştirmek için kodunun iskelesini.</span><span class="sxs-lookup"><span data-stu-id="e6739-164">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="e6739-165">Bu aynı ilkeler geçerlidir ek dizinleri ekleme, veritabanınızda ek tablolar da dahil olmak üzere, tablo, vb. üzerinde yer alan bir veritabanı görünümü EF eşleme.</span><span class="sxs-lookup"><span data-stu-id="e6739-165">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="e6739-166">EF modeli, veritabanı şeklini daha fazlasını içerir.</span><span class="sxs-lookup"><span data-stu-id="e6739-166">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="e6739-167">Modelin tamamı modeliniz ve bunların tablolar ve sütunlar için nasıl eşleneceğine sınıfları ve özellikleri hakkındaki bilgilere bakmak geçişlerini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6739-167">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="e6739-168">Bu bilgiler, geçişler, iskele oluşturulduğunu kodda daha akıllı olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6739-168">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="e6739-169">Örneğin, bir özellik geçişleri için eşlenen sütunun adını değiştirirseniz, aynı özellik – yalnızca veritabanı şeması varsa, sağlayan yapılamaz olmasını görüyorsunuz tarafından yeniden adlandırma algılayabilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-169">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="e6739-170">Hangi sorunları takım ortamları neden olur</span><span class="sxs-lookup"><span data-stu-id="e6739-170">What causes issues in team environments</span></span>

<span data-ttu-id="e6739-171">Bir uygulama üzerinde çalışan tek bir geliştirici olduğunda önceki bölümde çalışır harika iş akışı kapsamında.</span><span class="sxs-lookup"><span data-stu-id="e6739-171">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="e6739-172">Modele değişiklik yapmadan yalnızca kişi olması durumunda da iyi bir ekip ortamında çalışır.</span><span class="sxs-lookup"><span data-stu-id="e6739-172">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="e6739-173">Bu senaryoda modeli değişiklik, geçişler oluşturabilir ve bunları, kaynak denetimine gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-173">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="e6739-174">Diğer geliştiriciler değişikliklerinizi eşitleyin ve çalıştırma **veritabanını Güncelleştir** uygulanan şema değişiklikleri olması.</span><span class="sxs-lookup"><span data-stu-id="e6739-174">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="e6739-175">EF modeli değişiklikleri yaptıktan ve aynı anda kaynak denetimine gönderme birden fazla Geliştirici sahip ortaya çıkan sorunları başlayın.</span><span class="sxs-lookup"><span data-stu-id="e6739-175">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="e6739-176">Ne EF eksik yerel geçiş son eşitlenmiş olduğundan, başka bir geliştirici kaynak denetimine gönderdiği geçişler ile birleştirmek için birinci sınıf bir yoludur.</span><span class="sxs-lookup"><span data-stu-id="e6739-176">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="e6739-177">Bir birleştirme çakışması örneği</span><span class="sxs-lookup"><span data-stu-id="e6739-177">An example of a merge conflict</span></span>

<span data-ttu-id="e6739-178">İlk böyle bir birleştirme çakışması somut bir örneğe göz atalım.</span><span class="sxs-lookup"><span data-stu-id="e6739-178">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="e6739-179">Biz üzerinde daha önce inceledik örneğiyle devam edeceğiz.</span><span class="sxs-lookup"><span data-stu-id="e6739-179">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="e6739-180">Başlangıç olarak işaret şimdi önceki bölümde değişiklikleri iade özgün geliştirici tarafından varsayılır.</span><span class="sxs-lookup"><span data-stu-id="e6739-180">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="e6739-181">Bunlar kod için temel değişiklik olarak iki geliştiriciler izleriz.</span><span class="sxs-lookup"><span data-stu-id="e6739-181">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="e6739-182">EF modeli ve bir dizi değişiklik'ya kadar geçerli geçişleri izleriz.</span><span class="sxs-lookup"><span data-stu-id="e6739-182">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="e6739-183">Bir başlangıç noktası için aşağıdaki grafikte gösterildiği gibi kaynak denetim deposu için hem geliştiriciler eşitlediyseniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-183">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![StartingPoint](~/ef6/media/startingpoint.png)

<span data-ttu-id="e6739-185">Geliştirici \#1 ve geliştirici \#2 artık yapar bazı değişiklikleri kendi yerel kodda EF modeli temel.</span><span class="sxs-lookup"><span data-stu-id="e6739-185">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="e6739-186">Geliştirici \#1 ekler bir **derecelendirme** özelliğini **Blog** – ve oluşturan bir **AddRating** veritabanına değişiklikleri uygulamak için geçiş.</span><span class="sxs-lookup"><span data-stu-id="e6739-186">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="e6739-187">Geliştirici \#2 ekler bir **okuyucular** özelliğini **Blog** – ve karşılık gelen oluşturur **AddReaders** geçiş.</span><span class="sxs-lookup"><span data-stu-id="e6739-187">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="e6739-188">Her iki geliştiriciler çalıştırma **veritabanını Güncelleştir**, değişiklikleri kendi yerel veritabanlarına uygulayın ve ardından uygulama geliştirme devam edin.</span><span class="sxs-lookup"><span data-stu-id="e6739-188">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="e6739-189">Geçişleri bizim grafiğini temsil eden için bir zaman damgası ile öneki AddReaders geçiş'geliştiriciden \#2 geliştiriciden AddRating geçişten sonra gelen \#1.</span><span class="sxs-lookup"><span data-stu-id="e6739-189">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="e6739-190">Olmadığını Geliştirici \#1 veya \#takım ya da bunları sonraki bölümde bakacağız birleştirme işlemi çalışmanın sorunlara fark 2 oluşturulan geçiş ilk yapar.</span><span class="sxs-lookup"><span data-stu-id="e6739-190">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![LocalChanges](~/ef6/media/localchanges.png)

<span data-ttu-id="e6739-192">Bir geliştiricinin lucky gündür \#1 gelişmelerden önce yaptıkları değişiklikleri göndermek için.</span><span class="sxs-lookup"><span data-stu-id="e6739-192">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="e6739-193">Bunlar, depo eşitlenmiş olduğundan başka hiç kimse iade olduğundan, herhangi bir birleştirme işlemi yapmadan bunlar yalnızca değişikliklerini gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e6739-193">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![Gönder](~/ef6/media/submit.png)

<span data-ttu-id="e6739-195">Geliştirici zamanı artık \#göndermek için 2.</span><span class="sxs-lookup"><span data-stu-id="e6739-195">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="e6739-196">Bunlar, bu nedenle lucky değildir.</span><span class="sxs-lookup"><span data-stu-id="e6739-196">They aren’t so lucky.</span></span> <span data-ttu-id="e6739-197">Kullanıcılar eşitlenmiş olduğundan başkası değişiklikler gönderdi olduğundan, birleştirme ve değişiklikleri çekmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="e6739-197">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="e6739-198">Kaynak denetim sistemi, büyük olasılıkla çok basit olduğundan kod düzeyinde değişiklikleri otomatik olarak birleştirmek mümkün olacaktır.</span><span class="sxs-lookup"><span data-stu-id="e6739-198">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="e6739-199">Geliştirici durumunu \#2 yerel aşağıdaki grafikte gösterilen eşitlemeden sonra depo.</span><span class="sxs-lookup"><span data-stu-id="e6739-199">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![Çekme](~/ef6/media/pull.png)

<span data-ttu-id="e6739-201">Şu anda Geliştirici aşama \#2 çalıştırabilirsiniz **veritabanını Güncelleştir** hangi algılayacak yeni **AddRating** geçiş (hangi henüz uygulanmadığını Geliştirici \#2 veritabanı) ve uygulayın.</span><span class="sxs-lookup"><span data-stu-id="e6739-201">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="e6739-202">Artık **derecelendirme** sütun eklenir **blogları** tablo ve veritabanı modeli ile eşitlenmiş.</span><span class="sxs-lookup"><span data-stu-id="e6739-202">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="e6739-203">Ancak birkaç sorun vardır:</span><span class="sxs-lookup"><span data-stu-id="e6739-203">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="e6739-204">Ancak **veritabanını Güncelleştir** uygulanacak **AddRating** geçiş, da yükseltmek bir uyarı: *bekleyen değişiklikler olduğundan, geçerli model eşleştirilecek veritabanı güncelleştirilemiyor ve Otomatik geçişi devre dışı bırakıldı...*</span><span class="sxs-lookup"><span data-stu-id="e6739-204">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="e6739-205">Model anlık görüntü son geçişin depolanan sorunudur (**AddReader**) eksik **derecelendirme** özelliği **Blog** (modelinin bir parçası değildi beri olduğunda geçiş oluşturuldu).</span><span class="sxs-lookup"><span data-stu-id="e6739-205">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="e6739-206">Kod öncelikle son geçiş modelinde geçerli model eşleşmiyor ve uyarı meydana getirir algılar.</span><span class="sxs-lookup"><span data-stu-id="e6739-206">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="e6739-207">Uygulamayı çalıştıran InvalidOperationException belirten sonuçlanır "*veritabanı oluşturulduktan sonra 'BloggingContext' bağlam yedekleme modeli değişti. ... Veritabanını güncellemek için Code First Migrations'ı kullanmayı deneyin"*</span><span class="sxs-lookup"><span data-stu-id="e6739-207">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="e6739-208">Yeniden son geçişin depolanan modeli anlık görüntü geçerli model eşleşmeyen bir sorundur.</span><span class="sxs-lookup"><span data-stu-id="e6739-208">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="e6739-209">Son olarak, biz çalışmasını beklediğiniz **Ekle geçiş** (veritabanına uygulamak için herhangi bir değişiklik olduğundan) boş bir geçiş artık üretir.</span><span class="sxs-lookup"><span data-stu-id="e6739-209">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="e6739-210">Ancak geçişleri dışlanmaz çünkü geçerli model biri son geçiş (eksik olduğu **derecelendirme** özelliği) da aslında başka iskele **AddColumn** içinde eklemekiçinçağrı**Derecelendirme** sütun.</span><span class="sxs-lookup"><span data-stu-id="e6739-210">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="e6739-211">Doğal olarak, bu geçiş sırasında başarısız olacağı **veritabanını Güncelleştir** çünkü **derecelendirme** sütun zaten mevcut.</span><span class="sxs-lookup"><span data-stu-id="e6739-211">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="e6739-212">Birleştirme çakışması çözümleme</span><span class="sxs-lookup"><span data-stu-id="e6739-212">Resolving the merge conflict</span></span>

<span data-ttu-id="e6739-213">Güzel bir haberimiz var geçişleri nasıl çalıştığına ilişkin bir anlayış olması kaydıyla, birleştirme el ile – dağıtılacak çok zor olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="e6739-213">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="e6739-214">Bu bölüme atlandı devam varsa bunu...</span><span class="sxs-lookup"><span data-stu-id="e6739-214">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="e6739-215">Üzgünüz, geri dönün ve makalenin geri kalanında okumanız gerekir!</span><span class="sxs-lookup"><span data-stu-id="e6739-215">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="e6739-216">İki seçenek, bir anlık görüntü olarak doğru geçerli modeli olan boş bir geçiş oluşturmak için en kolay yoldur.</span><span class="sxs-lookup"><span data-stu-id="e6739-216">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="e6739-217">İkinci seçenek doğru olması için son geçiş anlık güncelleştirme, model anlık görüntü.</span><span class="sxs-lookup"><span data-stu-id="e6739-217">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="e6739-218">İkinci seçenek biraz daha zordur ve her senaryoda kullanılamaz, ancak fazladan bir geçiş ekleme içermeyen ayrıca temizleyici olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="e6739-218">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="e6739-219">1. seçenek: boş 'merge' geçiş Ekle</span><span class="sxs-lookup"><span data-stu-id="e6739-219">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="e6739-220">Bu seçenek yalnızca en son geçiş sahip emin olmak amacıyla boş bir geçiş oluşturduğumuz doğru model anlık görüntü depolanan içinde.</span><span class="sxs-lookup"><span data-stu-id="e6739-220">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="e6739-221">Bu seçenek bağımsız olarak, kimin son geçiş oluşturulan kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-221">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="e6739-222">Biz aşağıdaki Geliştirici örnekte \#2, birleştirme care sürüyor ve son geçiş oluşturmak için gerçekleştiği.</span><span class="sxs-lookup"><span data-stu-id="e6739-222">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="e6739-223">Ancak aynı adımları kullanılabilir Geliştirici \#1 oluşturulan son geçiş.</span><span class="sxs-lookup"><span data-stu-id="e6739-223">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="e6739-224">Adımlar, birden çok geçiş ilgili – biz yalnızca iki basit tutmak için arıyorsunuz durumunda da geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="e6739-224">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="e6739-225">Aşağıdaki işlem, kaynak denetiminden eşitlenmesi gereken değişiklikleri olması fark uygulanmasından itibaren bu yaklaşım için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-225">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="e6739-226">Tüm bekleyen model değişiklikleri yerel kod tabanınızın bir geçiş için yazılmış emin olun.</span><span class="sxs-lookup"><span data-stu-id="e6739-226">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="e6739-227">Bu adım, boş bir geçiş oluşturmak için zaman geldiğinde yasal değişiklikleri kaçırmayın sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6739-227">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="e6739-228">Kaynak denetimi ile eşitleyin.</span><span class="sxs-lookup"><span data-stu-id="e6739-228">Sync with source control.</span></span>
3.  <span data-ttu-id="e6739-229">Çalıştırma **veritabanını Güncelleştir** diğer geliştiriciler iade herhangi bir yeni geçişler uygulamak için.</span><span class="sxs-lookup"><span data-stu-id="e6739-229">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="e6739-230">\*\*
    *Not: \*\*\* tüm uyarılar veritabanını Güncelleştir komutundan elde etmezsiniz sonra hiçbir yeni geçiş diğer geliştiricilerden vardı ve herhangi ek birleştirme gerçekleştirmek için gerek yoktur.*</span><span class="sxs-lookup"><span data-stu-id="e6739-230">**
*Note:****if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="e6739-231">Çalıştırma **Ekle geçiş &lt;çekme\_bir\_adı&gt; – IgnoreChanges** (örneğin, **Ekle geçiş birleştirme – IgnoreChanges**).</span><span class="sxs-lookup"><span data-stu-id="e6739-231">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="e6739-232">Bu (geçerli modelinkiyle anlık görüntüsünü dahil) tüm meta verileriyle bir geçiş oluşturur, ancak geçerli model için son geçişlerin anlık karşılaştırılırken algıladığı herhangi bir değişiklik göz ardı eder (boş alma anlamı **yukarı** ve **Aşağı** yöntemi).</span><span class="sxs-lookup"><span data-stu-id="e6739-232">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="e6739-233">Geliştirmeye devam veya kaynak denetimi (birim Elbette testleri sonra) gönderin.</span><span class="sxs-lookup"><span data-stu-id="e6739-233">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="e6739-234">İşte Geliştirici durumunu \#2 yerel kod bu yaklaşım kullandıktan sonra temel.</span><span class="sxs-lookup"><span data-stu-id="e6739-234">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![MergeMigration](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="e6739-236">2. seçenek: son geçiş modeli anlık güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="e6739-236">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="e6739-237">Bu seçenek seçeneği 1 çok benzer, ancak ek boş geçişi – çünkü kaldırır, ek bir kod dosyalarında çözüm isteyen şimdi yüz tanıma.</span><span class="sxs-lookup"><span data-stu-id="e6739-237">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="e6739-238">**Bu yaklaşım yalnızca en son geçiş, yalnızca yerel kod tabanınızın var ve (örneğin, son geçiş birleştirme yapan kullanıcı tarafından oluşturulmuşsa) henüz kaynak denetimine gönderilmedi uygulanabilirdir**.</span><span class="sxs-lookup"><span data-stu-id="e6739-238">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="e6739-239">Diğer geliştiricilerin zaten kendi geliştirme veritabanı – veya hatta uyguladınız geçişleri meta verilerini düzenleme daha da kötüsü üretim veritabanına – uygulanan beklenmeyen etkilere neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-239">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="e6739-240">İşlem sırasında son geçişi yerel veritabanımızda yer geri ve güncelleştirilmiş meta verileriyle yeniden uygulamak için ekleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="e6739-240">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="e6739-241">Yalnızca son geçiş gereksinimlerini yerel kod tabanı sayısı veya devam geçişleri sırasını kısıtlama yoktur olması.</span><span class="sxs-lookup"><span data-stu-id="e6739-241">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="e6739-242">Birden çok geçiş birden çok farklı geliştiricilerden olabilir ve aynı adımları uygulayın: biz yalnızca iki basit tutmak için arıyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="e6739-242">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="e6739-243">Aşağıdaki işlem, kaynak denetiminden eşitlenmesi gereken değişiklikleri olması fark uygulanmasından itibaren bu yaklaşım için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-243">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="e6739-244">Tüm bekleyen model değişiklikleri yerel kod tabanınızın bir geçiş için yazılmış emin olun.</span><span class="sxs-lookup"><span data-stu-id="e6739-244">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="e6739-245">Bu adım, boş bir geçiş oluşturmak için zaman geldiğinde yasal değişiklikleri kaçırmayın sağlar.</span><span class="sxs-lookup"><span data-stu-id="e6739-245">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="e6739-246">Kaynak denetimi ile eşitleyin.</span><span class="sxs-lookup"><span data-stu-id="e6739-246">Sync with the source control.</span></span>
3.  <span data-ttu-id="e6739-247">Çalıştırma **veritabanını Güncelleştir** diğer geliştiriciler iade herhangi bir yeni geçişler uygulamak için.</span><span class="sxs-lookup"><span data-stu-id="e6739-247">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="e6739-248">\*\*
    *Not: \*\*\* tüm uyarılar veritabanını Güncelleştir komutundan elde etmezsiniz sonra hiçbir yeni geçiş diğer geliştiricilerden vardı ve herhangi ek birleştirme gerçekleştirmek için gerek yoktur.*</span><span class="sxs-lookup"><span data-stu-id="e6739-248">**
*Note:****if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="e6739-249">Çalıştırma **veritabanını güncelleştir – TargetMigration &lt;ikinci\_son\_geçiş&gt;**  (biz aşağıdaki örnekte bu olacaktır **-veritabanı – güncelleştirme TargetMigration AddRating**).</span><span class="sxs-lookup"><span data-stu-id="e6739-249">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="e6739-250">Bu veritabanını yedeklemek için ikinci durumunu rolleri son geçişi – etkili bir şekilde 'beklemediğiniz uygulanan' veritabanından son geçiş.</span><span class="sxs-lookup"><span data-stu-id="e6739-250">This roles the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="e6739-251">\*\*
    *Not: \*\*\* olduğundan meta veriler de depolanan meta veriler geçişin düzenlemek güvenli hale getirmek için bu adım gereklidir \_ \_MigrationsHistoryTable veritabanı. Yalnızca son geçiş yalnızca yerel kodunuzda temel varsa bu seçeneği kullanmalısınız nedeni budur. Diğer veritabanlarının uygulanan son geçiş olsaydı geri alma ve meta verileri güncelleştirmek için son geçiş yeniden uygulamanız gerekir.*</span><span class="sxs-lookup"><span data-stu-id="e6739-251">**
*Note:****This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="e6739-252">Çalıştırma **Ekle geçiş &lt;tam\_adı\_dahil olmak üzere\_zaman damgası\_,\_son\_geçiş** &gt; (örnekte Biz başlangıcındaki bu aşağıdakine benzer olacaktır **Ekle geçiş 201311062215252\_AddReaders**).</span><span class="sxs-lookup"><span data-stu-id="e6739-252">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="e6739-253">\*\*
    *Not: \*\*\* geçişleri bilebilmesi yeni bir yapı iskelesini oluşturmak yerine var olan geçiş düzenlemek istediğiniz zaman damgası eklemeniz gerekir.*</span><span class="sxs-lookup"><span data-stu-id="e6739-253">**
    *Note:****You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
<span data-ttu-id="e6739-254">Bu, geçerli model eşleşecek şekilde son geçiş için meta verileri güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="e6739-254">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="e6739-255">Komut tamamlandıktan, ancak tam olarak istediğiniz zaman aşağıdaki uyarıyı alırsınız.</span><span class="sxs-lookup"><span data-stu-id="e6739-255">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="e6739-256">"*Yalnızca geçiş ' 201311062215252 Tasarımcısı kodunu\_AddReaders yeniden iskele kurulmuş. Tüm geçiş yeniden iskelesini kullanın - Force parametresini. "*</span><span class="sxs-lookup"><span data-stu-id="e6739-256">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="e6739-257">Çalıştırma **veritabanını Güncelleştir** güncelleştirilmiş meta verilerin en son geçiş yeniden uygulamak için.</span><span class="sxs-lookup"><span data-stu-id="e6739-257">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="e6739-258">Geliştirmeye devam veya kaynak denetimi (birim Elbette testleri sonra) gönderin.</span><span class="sxs-lookup"><span data-stu-id="e6739-258">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="e6739-259">İşte Geliştirici durumunu \#2 yerel kod bu yaklaşım kullandıktan sonra temel.</span><span class="sxs-lookup"><span data-stu-id="e6739-259">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![UpdatedMetadata](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="e6739-261">Özet</span><span class="sxs-lookup"><span data-stu-id="e6739-261">Summary</span></span>

<span data-ttu-id="e6739-262">Bir ekip ortamında Code First Migrations'ı kullanırken, bazı zorluklar vardır.</span><span class="sxs-lookup"><span data-stu-id="e6739-262">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="e6739-263">Ancak, temel bir anlayışa geçişleri nasıl çalıştığını ve birleştirme çakışmalarını çözmek için basit yaklaşımlardan kolaylaştırır bu zorluklarının üstesinden gelin.</span><span class="sxs-lookup"><span data-stu-id="e6739-263">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="e6739-264">Temel sorunu, en son geçişin depolanan yanlış meta verilerdir.</span><span class="sxs-lookup"><span data-stu-id="e6739-264">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="e6739-265">Bu ilk kod geçerli model ve veritabanı şeması eşleşmeyen yanlış algılamak için ve sonraki geçişin yanlış kodunun iskelesini neden olur.</span><span class="sxs-lookup"><span data-stu-id="e6739-265">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="e6739-266">Bu durum, doğru modeli ile boş bir geçiş oluşturmak ya da son geçiş meta verilerde güncelleştirme üstesinden gelebilir.</span><span class="sxs-lookup"><span data-stu-id="e6739-266">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
