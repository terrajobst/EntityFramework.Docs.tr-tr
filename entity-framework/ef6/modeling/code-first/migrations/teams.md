---
title: Ekip ortamlarında Code First Migrations-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: b3c4c35d636caf4ddd251dd78e026587abc57d42
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78418891"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="664ce-102">Ekip ortamlarında Code First Migrations</span><span class="sxs-lookup"><span data-stu-id="664ce-102">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="664ce-103">Bu makalede temel senaryolarda Code First Migrations kullanmayı bildiğiniz varsayılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="664ce-103">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="664ce-104">Bunu yapmazsanız devam etmeden önce [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) okumanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="664ce-104">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="664ce-105">Kahve, bu makalenin tamamını okumanız gerekir</span><span class="sxs-lookup"><span data-stu-id="664ce-105">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="664ce-106">Ekip ortamlarındaki sorunlar, iki geliştirici yerel kod tabanında geçişler oluştururken geçişleri birleştirme konusunda büyük bir yerdedir.</span><span class="sxs-lookup"><span data-stu-id="664ce-106">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="664ce-107">Bunları çözmeye yönelik adımlar oldukça basittir, ancak geçiş işlemlerinin nasıl çalıştığına ilişkin katı bir anlama sahip olmanızı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="664ce-107">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="664ce-108">Lütfen sonuna kadar atlayın; başarılı olduğunuzdan emin olmak için makalenin tamamını okumaya devam edin.</span><span class="sxs-lookup"><span data-stu-id="664ce-108">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="664ce-109">Bazı genel yönergeler</span><span class="sxs-lookup"><span data-stu-id="664ce-109">Some general guidelines</span></span>

<span data-ttu-id="664ce-110">Birden çok geliştirici tarafından oluşturulan birleştirme geçişlerinin nasıl yönetileceğini öğrenmek için, bu işlemin başarılı olup olmadığını ayarlamak için bazı genel yönergeler aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="664ce-110">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="664ce-111">Her takım üyesinin yerel bir geliştirme veritabanına sahip olması gerekir</span><span class="sxs-lookup"><span data-stu-id="664ce-111">Each team member should have a local development database</span></span>

<span data-ttu-id="664ce-112">Geçişler, hangi geçişlerin veritabanına uygulandığını saklamak için **\_\_MigrationsHistory** tablosunu kullanır.</span><span class="sxs-lookup"><span data-stu-id="664ce-112">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="664ce-113">Aynı veritabanını hedeflemek (ve bu nedenle bir **\_\_MigrationsHistory** tablo) için farklı geçişler üreten birden çok geliştirici varsa, geçişler çok karıştırılır.</span><span class="sxs-lookup"><span data-stu-id="664ce-113">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="664ce-114">Tabii ki, geçiş üretmeyen ekip üyeleriniz varsa, bunların merkezi bir geliştirme veritabanını paylaşmasına gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="664ce-114">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="664ce-115">Otomatik geçişlere engel</span><span class="sxs-lookup"><span data-stu-id="664ce-115">Avoid automatic migrations</span></span>

<span data-ttu-id="664ce-116">Alt çizgi, otomatik geçişlerin takım ortamlarında iyi şekilde bakmasıdır, ancak gerçekte yalnızca çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="664ce-116">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="664ce-117">Nedenini, okumayı koruyun – yoksa, sonraki bölüme atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="664ce-117">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="664ce-118">Otomatik geçişler, kod dosyaları üretmesine gerek kalmadan, veritabanı şemanızın geçerli modelle eşleşecek şekilde güncelleştirilmesini sağlar (kod tabanlı geçişler).</span><span class="sxs-lookup"><span data-stu-id="664ce-118">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="664ce-119">Yalnızca kullandıysanız ve kod tabanlı geçişler oluşturmadıysa otomatik geçişler bir ekip ortamında oldukça iyi çalışır.</span><span class="sxs-lookup"><span data-stu-id="664ce-119">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="664ce-120">Bu sorun, otomatik geçişlerin sınırlı olduğu ve bir dizi işlemin (özellik/sütun yeniden adlandırmaları, verileri başka bir tabloya taşıma vb.) sınırlandırılmasıdır. Bu senaryoları işlemek için, otomatik geçişler tarafından işlenen değişiklikler arasında karma olan kod tabanlı geçişler (ve yapı iskelesi kodunu düzenleyerek) sonlandırın.</span><span class="sxs-lookup"><span data-stu-id="664ce-120">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="664ce-121">Bu, iki geliştirici geçişi iade edildiğinde değişiklikleri birleştirme imkanını neredeyse olanaksız hale getirir.</span><span class="sxs-lookup"><span data-stu-id="664ce-121">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="664ce-122">Tasarlandı</span><span class="sxs-lookup"><span data-stu-id="664ce-122">Screencasts</span></span>

<span data-ttu-id="664ce-123">Bu makaleyi okuduğunuzdan bir ekran koruyucu izlemeyi tercih ediyorsanız, aşağıdaki iki video bu makaleyle aynı içeriği kapsar.</span><span class="sxs-lookup"><span data-stu-id="664ce-123">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="664ce-124">Video One: "geçişler-,"</span><span class="sxs-lookup"><span data-stu-id="664ce-124">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="664ce-125">[Bu ekran kaydı](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) , geçişlerin, model değişikliklerini algılamak için model hakkındaki bilgileri nasıl izlediğini ve kullandığını ele alır.</span><span class="sxs-lookup"><span data-stu-id="664ce-125">[This screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="664ce-126">Video Iki: "geçişler-ekip ortamları"</span><span class="sxs-lookup"><span data-stu-id="664ce-126">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="664ce-127">Önceki videodaki kavramlar üzerinde oluşturma, [Bu ekran](https://channel9.msdn.com/blogs/ef/migrations-team-environments) görüntüsü bir ekip ortamında oluşan sorunları ve bunları nasıl çözebileceğini ele alır.</span><span class="sxs-lookup"><span data-stu-id="664ce-127">Building on the concepts from the previous video, [this screencast](https://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="664ce-128">Geçişlerin nasıl çalıştığını anlama</span><span class="sxs-lookup"><span data-stu-id="664ce-128">Understanding how migrations works</span></span>

<span data-ttu-id="664ce-129">Bir ekip ortamında geçişleri başarıyla kullanmaya yönelik anahtar, geçişlerin nasıl izlediği ve model değişikliklerini algılamak için model hakkındaki bilgileri nasıl izlediğini anlayabiliyor.</span><span class="sxs-lookup"><span data-stu-id="664ce-129">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="664ce-130">İlk geçiş</span><span class="sxs-lookup"><span data-stu-id="664ce-130">The first migration</span></span>

<span data-ttu-id="664ce-131">Projenize ilk geçişi eklediğinizde, Paket Yöneticisi konsolunda **önce geçiş Ekle** gibi bir şey çalıştırırsınız.</span><span class="sxs-lookup"><span data-stu-id="664ce-131">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="664ce-132">Bu komutun gerçekleştirdiği üst düzey adımlar aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="664ce-132">The high level steps that this command performs are pictured below.</span></span>

![İlk geçiş](~/ef6/media/firstmigration.png)

<span data-ttu-id="664ce-134">Geçerli model, kodunuzda (1) hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="664ce-134">The current model is calculated from your code (1).</span></span> <span data-ttu-id="664ce-135">Gerekli veritabanı nesneleri daha sonra model tarafından hesaplanır (2). bu ilk geçiş olduğundan, model farklı bir şekilde karşılaştırma için yalnızca boş bir model kullanır.</span><span class="sxs-lookup"><span data-stu-id="664ce-135">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="664ce-136">Gerekli değişiklikler kod oluşturucusuna geçirilir ve daha sonra Visual Studio çözümünüze (4) eklenen gerekli geçiş kodunu (3) oluşturur.</span><span class="sxs-lookup"><span data-stu-id="664ce-136">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="664ce-137">Ana kod dosyasında depolanan gerçek geçiş koduna ek olarak geçişler de bazı ek arka plan kod dosyaları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="664ce-137">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="664ce-138">Bu dosyalar, geçişler tarafından kullanılan ve düzenlemeniz gereken bir şey olmayan meta verilerlerdir.</span><span class="sxs-lookup"><span data-stu-id="664ce-138">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="664ce-139">Bu dosyalardan biri, geçişin oluşturulduğu sırada modelin anlık görüntüsünü içeren bir kaynak dosyasıdır (. resx).</span><span class="sxs-lookup"><span data-stu-id="664ce-139">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="664ce-140">Bu, bir sonraki adımda nasıl kullanıldığını görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="664ce-140">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="664ce-141">Bu noktada, değişiklikleri veritabanına uygulamak için büyük olasılıkla **Update-Database** ' i çalıştırıp uygulamanızın diğer bölgelerini uygulamaya gidebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="664ce-141">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="664ce-142">Sonraki geçişler</span><span class="sxs-lookup"><span data-stu-id="664ce-142">Subsequent migrations</span></span>

<span data-ttu-id="664ce-143">Daha sonra modelinize geri dönüp modelinizde bazı değişiklikler yaparsınız. bizim örneğimizde, **blogda**bir **URL** özelliği ekleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="664ce-143">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="664ce-144">Ardından, karşılık gelen veritabanı değişikliklerini uygulamak üzere bir geçişe geçiş yapmak için **Add-Migration AddUrl** gibi bir komut verirsiniz.</span><span class="sxs-lookup"><span data-stu-id="664ce-144">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="664ce-145">Bu komutun gerçekleştirdiği üst düzey adımlar aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="664ce-145">The high level steps that this command performs are pictured below.</span></span>

![İkinci geçiş](~/ef6/media/secondmigration.png)

<span data-ttu-id="664ce-147">Son kez olduğu gibi, geçerli model koddan hesaplanır (1).</span><span class="sxs-lookup"><span data-stu-id="664ce-147">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="664ce-148">Ancak, bu kez, önceki modelin en son geçişten (2) alınması için mevcut geçişler vardır.</span><span class="sxs-lookup"><span data-stu-id="664ce-148">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="664ce-149">Bu iki model, gerekli veritabanı değişikliklerini (3) bulmak için dağıtılır ve sonra işlemin daha önce olduğu gibi tamamlanır.</span><span class="sxs-lookup"><span data-stu-id="664ce-149">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="664ce-150">Bu işlem, projeye eklediğiniz diğer geçişler için de kullanılır.</span><span class="sxs-lookup"><span data-stu-id="664ce-150">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="664ce-151">Model anlık görüntüsüne neden neden olsıther?</span><span class="sxs-lookup"><span data-stu-id="664ce-151">Why bother with the model snapshot?</span></span>

<span data-ttu-id="664ce-152">Model anlık görüntüsüne neden olduğunu merak ediyor olabilirsiniz; bu nedenle veritabanına bakmasınız.</span><span class="sxs-lookup"><span data-stu-id="664ce-152">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="664ce-153">Öyleyse, okumaya devam edin.</span><span class="sxs-lookup"><span data-stu-id="664ce-153">If so, read on.</span></span> <span data-ttu-id="664ce-154">İlgilenmiyorsanız, bu bölümü atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="664ce-154">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="664ce-155">Bir dizi nedenden dolayı model anlık görüntüsünün etrafında devam eder:</span><span class="sxs-lookup"><span data-stu-id="664ce-155">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="664ce-156">Veritabanınızın EF modelinden ft 'e erişmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="664ce-156">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="664ce-157">Bu değişiklikler doğrudan veritabanında yapılabilir veya değişiklikleri yapmak için geçişlerinizin scafkatlama kodunu değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="664ce-157">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="664ce-158">İşte bu uygulamada birkaç örnek aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="664ce-158">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="664ce-159">Bir veya daha fazla tabloünize ekli ve güncelleştirilmiş bir sütunu eklemek istiyorsunuz, ancak bu sütunları EF modeline eklemek istemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="664ce-159">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="664ce-160">Geçişler veritabanına bakıyorsa, bir geçişi her kullandığınızda sürekli olarak bu sütunları bırakmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="664ce-160">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="664ce-161">Model anlık görüntüsünü kullanarak, EF yalnızca modeldeki meşru değişiklikleri algılar.</span><span class="sxs-lookup"><span data-stu-id="664ce-161">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="664ce-162">Güncelleştirmeler için kullanılan saklı yordamın gövdesini, bazı günlükleri içerecek şekilde değiştirmek istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="664ce-162">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="664ce-163">Geçişler veritabanından bu saklı yordama bakıyorsa, bu işlemi sürekli olarak dener ve EF 'in beklediği tanıma yeniden sıfırlar.</span><span class="sxs-lookup"><span data-stu-id="664ce-163">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="664ce-164">Model anlık görüntüsünü kullanarak EF yalnızca, EF modelindeki yordamın şeklini değiştirirken saklı yordamı değiştirmek için bir kod kullanacaktır.</span><span class="sxs-lookup"><span data-stu-id="664ce-164">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="664ce-165">Aynı ilkeler, veritabanınıza ek tablolar dahil olmak üzere ek dizinler eklemek, EF 'i tablo üzerinde yer alan bir veritabanı görünümüyle eşleştirmek için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="664ce-165">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="664ce-166">EF modeli yalnızca veritabanının şeklinin fazlasını içerir.</span><span class="sxs-lookup"><span data-stu-id="664ce-166">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="664ce-167">Modelin tamamının olması, geçiş geçişlerinin modelinizdeki Özellikler ve sınıflar hakkındaki bilgilere ve bunların sütunlarına ve tablolarla nasıl eşlenmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="664ce-167">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="664ce-168">Bu bilgiler, geçişlerinin, dolandırıcıların bulduğu kodda daha akıllı olmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="664ce-168">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="664ce-169">Örneğin, bir özelliğin geçişlerle eşlendiği sütunun adını değiştirirseniz, yalnızca veritabanı şemasına sahipseniz, bu özelliğin aynı özelliği olduğunu görerek yeniden adlandırma işlemi algılayabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-169">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="664ce-170">Takım ortamlarında sorunlara neden olur</span><span class="sxs-lookup"><span data-stu-id="664ce-170">What causes issues in team environments</span></span>

<span data-ttu-id="664ce-171">Önceki bölümde ele alınan iş akışı, bir uygulama üzerinde çalışan tek bir geliştirici olduğunuzda harika bir şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="664ce-171">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="664ce-172">Ayrıca, modelde değişiklik yapan tek kişiyseniz, bir ekip ortamında da iyi bir şekilde çalışacaktır.</span><span class="sxs-lookup"><span data-stu-id="664ce-172">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="664ce-173">Bu senaryoda model değişiklikleri yapabilir, geçişler oluşturabilir ve bunları kaynak denetimize gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="664ce-173">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="664ce-174">Diğer geliştiriciler değişiklikleri eşitleyebilir ve şema değişikliklerinin uygulanmasını sağlamak için **Update-Database** ' i çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-174">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="664ce-175">Çok sayıda geliştirici, EF modelinde değişiklik yaparken ve kaynak denetimine aynı anda gönderim yaptığınızda sorun oluşur.</span><span class="sxs-lookup"><span data-stu-id="664ce-175">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="664ce-176">En son eşitleme işleminden bu yana başka bir geliştiricinin kaynak denetimine gönderdiği geçişlerle yerel geçişlerinizi birleştirmenin ilk sınıf yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="664ce-176">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="664ce-177">Birleştirme çakışması örneği</span><span class="sxs-lookup"><span data-stu-id="664ce-177">An example of a merge conflict</span></span>

<span data-ttu-id="664ce-178">İlk olarak, bu tür birleştirme çakışmasına ait somut bir örneğe bakalım.</span><span class="sxs-lookup"><span data-stu-id="664ce-178">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="664ce-179">Daha önce bakdığımız örnekle devam edeceğiz.</span><span class="sxs-lookup"><span data-stu-id="664ce-179">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="664ce-180">Başlangıç noktası olarak, önceki bölümdeki değişikliklerin özgün geliştirici tarafından iade edilmiş olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="664ce-180">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="664ce-181">Kod tabanında değişiklik yaptıkları için iki geliştirici izliyoruz.</span><span class="sxs-lookup"><span data-stu-id="664ce-181">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="664ce-182">EF modelini ve geçişleri bir dizi değişiklik aracılığıyla izliyoruz.</span><span class="sxs-lookup"><span data-stu-id="664ce-182">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="664ce-183">Bir başlangıç noktası için, her iki geliştirici aşağıdaki grafikte gösterildiği gibi kaynak denetimi deposu ile eşitlenir.</span><span class="sxs-lookup"><span data-stu-id="664ce-183">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![Başlangıç noktası](~/ef6/media/startingpoint.png)

<span data-ttu-id="664ce-185">Geliştirici \#1 ve geliştirici \#2 artık yerel kod tabanında EF modelinde bazı değişiklikler yapar.</span><span class="sxs-lookup"><span data-stu-id="664ce-185">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="664ce-186">Geliştirici \#1 **Blog** 'A bir **Derecelendirme** özelliği ekler ve değişiklikleri veritabanına uygulamak için bir **addderecelendirme** geçişi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="664ce-186">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="664ce-187">Geliştirici \#2 **Blog** 'A bir **Okuyucular** özelliği ekler ve ilgili **addokuyucular** geçişini oluşturur.</span><span class="sxs-lookup"><span data-stu-id="664ce-187">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="664ce-188">Her iki geliştirici da, değişiklikleri yerel veritabanlarına uygulamak için **Update-Database**' i çalıştırır ve ardından uygulamayı geliştirmeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="664ce-188">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="664ce-189">Geçişlere bir zaman damgası eklenir, bu nedenle grafiğimiz, geliştirici \#2 ' den alınan Addokuyucular geçişinin, geliştiriciden gelen Addderecelendirmede \#1 ' den sonra geldiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="664ce-189">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="664ce-190">Geliştirici \#1 veya \#2 ' nin tarafından oluşturulup oluşturulmayacağı, önce bir takımda çalışma sorunları veya bir sonraki bölümde bakacağımız birleştirme sürecinde hiçbir fark yapmaz.</span><span class="sxs-lookup"><span data-stu-id="664ce-190">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![Yerel değişiklikler](~/ef6/media/localchanges.png)

<span data-ttu-id="664ce-192">Bu, geliştirici \#1 ' in ilk yaptığı değişiklikleri göndermesi gibi bir gün için bir Backy günüdür.</span><span class="sxs-lookup"><span data-stu-id="664ce-192">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="664ce-193">Depolamalarını eşitlediği için başka hiç kimse iade ettiğinden, herhangi bir birleştirme gerçekleştirmeden yalnızca kendi değişikliklerini gönderebilirler.</span><span class="sxs-lookup"><span data-stu-id="664ce-193">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![Gönder](~/ef6/media/submit.png)

<span data-ttu-id="664ce-195">Artık geliştirici \#2 ' nin göndermesi zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-195">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="664ce-196">Bunlar bu kadar Lucky değildir.</span><span class="sxs-lookup"><span data-stu-id="664ce-196">They aren’t so lucky.</span></span> <span data-ttu-id="664ce-197">Eşitlendikleri tarihten sonra başka birisi tarafından gönderilmiş olduğundan, değişiklikler ve birleştirme işlemini çekmeleri gerekir.</span><span class="sxs-lookup"><span data-stu-id="664ce-197">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="664ce-198">Kaynak denetim sistemi, büyük olasılıkla, değişiklikler çok basittir çünkü kod düzeyinde otomatik olarak birleştirebilecektir.</span><span class="sxs-lookup"><span data-stu-id="664ce-198">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="664ce-199">Aşağıdaki grafikte, geliştirici \#2 ' nin yerel deposu, eşitlemeden sonra durum olarak gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="664ce-199">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![Çekme](~/ef6/media/pull.png)

<span data-ttu-id="664ce-201">Bu aşamada \#2, **Update-Database** ' i çalıştırabilir ve bu da yeni **addderecelendirme** geçişini algılar (Bu, geliştirici \#2 veritabanına uygulanmaz) ve uygulamayı uygular.</span><span class="sxs-lookup"><span data-stu-id="664ce-201">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="664ce-202">Artık **Derecelendirme** sütunu **Bloglar** tablosuna eklenir ve veritabanı modelle eşitlenmiş durumda.</span><span class="sxs-lookup"><span data-stu-id="664ce-202">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="664ce-203">Ancak birkaç sorun vardır:</span><span class="sxs-lookup"><span data-stu-id="664ce-203">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="664ce-204">**Update-Database** , **addderecelendirme** geçişini uygulayacağından, bu da bir uyarı oluşturacak: *bekleyen değişiklikler olduğundan ve otomatik geçiş devre dışı bırakıldığı için veritabanı geçerli modelle eşleşecek şekilde güncelleştirilemiyor...*</span><span class="sxs-lookup"><span data-stu-id="664ce-204">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="664ce-205">Bu sorun, son geçişte (**Addreader**) depolanan model anlık görüntüsünün, **blogdaki** **Derecelendirme** özelliğinin (geçiş oluşturulduğunda modelin bir parçası olmadığı için) eksik olması olabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-205">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="664ce-206">Code First, son geçiş içindeki modelin geçerli modelle eşleştiğini algılar ve uyarıyı yükseltir.</span><span class="sxs-lookup"><span data-stu-id="664ce-206">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="664ce-207">Uygulamanın çalıştırılması,*veritabanı oluşturulduktan sonra "BloggingContext ' bağlamını yedekleyen modelin değiştiğini belirten bir InvalidOperationException ile sonuçlanır. Veritabanını güncelleştirmek için Code First Migrations kullanmayı düşünün... "*</span><span class="sxs-lookup"><span data-stu-id="664ce-207">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="664ce-208">Bu sorun, son geçişte depolanan model anlık görüntüsünün geçerli modelle eşleşmez.</span><span class="sxs-lookup"><span data-stu-id="664ce-208">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="664ce-209">Son olarak, şimdi de, çalışma **geçişinin** daha sonra boş bir geçiş oluşturması beklenir (veritabanına uygulanacak bir değişiklik olmadığı için).</span><span class="sxs-lookup"><span data-stu-id="664ce-209">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="664ce-210">Ancak geçişler geçerli modeli son geçişten ( **Derecelendirme** özelliği eksik) ile karşılaştırdığından, **Derecelendirme** sütununa eklemek Için başka bir **AddColumn** çağrısını gerçekten bir şekilde ele alacak.</span><span class="sxs-lookup"><span data-stu-id="664ce-210">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="664ce-211">Tabii ki, bu geçiş **Update-Database** sırasında başarısız olur çünkü **Derecelendirme** sütunu zaten var.</span><span class="sxs-lookup"><span data-stu-id="664ce-211">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="664ce-212">Birleştirme çakışmasını çözme</span><span class="sxs-lookup"><span data-stu-id="664ce-212">Resolving the merge conflict</span></span>

<span data-ttu-id="664ce-213">İyi haber, geçişlerin nasıl çalıştığına ilişkin daha fazla bilgiye sahip olmanız kaydıyla, birleştirmeye el ile ilgilenmek çok zor değildir.</span><span class="sxs-lookup"><span data-stu-id="664ce-213">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="664ce-214">Bu nedenle, bu bölümde daha önce atladıysanız...</span><span class="sxs-lookup"><span data-stu-id="664ce-214">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="664ce-215">Ne yazık ki geri dönüp önce makalenin geri kalanını okumanız gerekir!</span><span class="sxs-lookup"><span data-stu-id="664ce-215">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="664ce-216">İki seçenek vardır. Bu, en kolay bir anlık görüntü olarak doğru geçerli modele sahip boş bir geçiş oluşturmadır.</span><span class="sxs-lookup"><span data-stu-id="664ce-216">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="664ce-217">İkinci seçenek, son geçişte anlık görüntüyü doğru model anlık görüntüsüne sahip olacak şekilde güncelleştirmedir.</span><span class="sxs-lookup"><span data-stu-id="664ce-217">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="664ce-218">İkinci seçenek biraz daha zordur ve her senaryoda kullanılamaz, ancak ek bir geçiş eklemeyi içermediğinden de temizleyici olur.</span><span class="sxs-lookup"><span data-stu-id="664ce-218">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="664ce-219">Seçenek 1: boş bir ' Merge ' geçişi ekleyin</span><span class="sxs-lookup"><span data-stu-id="664ce-219">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="664ce-220">Bu seçenekte, yalnızca en son geçişin doğru model anlık görüntüsüne sahip olduğundan emin olmak amacıyla yalnızca bir boş geçiş oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="664ce-220">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="664ce-221">Bu seçenek, son geçişi kimin oluşturmuş olduğunuza bakılmaksızın kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-221">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="664ce-222">Aşağıda, geliştirici \#2 ' nin birleştirme işlemini yaptığımız ve son geçişi oluşturma işlemi gerçekleştireceğiz.</span><span class="sxs-lookup"><span data-stu-id="664ce-222">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="664ce-223">Ancak, geliştirici \#1 son geçişi oluşturduğu takdirde aynı adımlar kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-223">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="664ce-224">Bu adımlar, birden çok geçiş söz konusu olduğunda da geçerlidir. Bu, en basit durumda tutulması için yalnızca iki tane bakıyorduk.</span><span class="sxs-lookup"><span data-stu-id="664ce-224">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="664ce-225">Aşağıdaki işlem, kaynak denetiminden eşitlenmesi gereken değişiklikler olduğunu fark ettiğiniz zamandan itibaren bu yaklaşım için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-225">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="664ce-226">Yerel kod tabanınız içindeki bekleyen model değişikliklerinin bir geçişe yazıldığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="664ce-226">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="664ce-227">Bu adım, boş geçiş oluşturmak için zaman geldiğinde herhangi bir yasal değişikliği kaçırmamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="664ce-227">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="664ce-228">Kaynak denetimiyle eşitleyin.</span><span class="sxs-lookup"><span data-stu-id="664ce-228">Sync with source control.</span></span>
3.  <span data-ttu-id="664ce-229">Diğer geliştiricilerin denetlediği yeni geçişleri uygulamak için **Update-Database** ' i çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="664ce-229">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="664ce-230">**_Note:_** *Update-Database komutundan herhangi bir uyarı alamazsanız, diğer geliştiricilerden yeni geçiş yoktu ve daha fazla birleştirme gerçekleştirmeye gerek yoktur.*</span><span class="sxs-lookup"><span data-stu-id="664ce-230">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="664ce-231">**Add-migration &lt;\_\_bir adı&gt; – ıgnorechanges** (örneğin, **Add-Migration Merge – ıgnorechanges**) çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="664ce-231">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="664ce-232">Bu, tüm meta veriler (geçerli modelin anlık görüntüsü dahil) ile bir geçiş oluşturur, ancak geçerli model son geçişlerde anlık görüntüyle karşılaştırılırken algıladığı tüm değişiklikleri yoksayar (boş bir **yukarı** ve **aşağı** yöntemi alırsınız).</span><span class="sxs-lookup"><span data-stu-id="664ce-232">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="664ce-233">Geliştirmeye devam edin veya kaynak denetimine gönderim yapın (kendi birim testlerinizi çalıştırdıktan sonra).</span><span class="sxs-lookup"><span data-stu-id="664ce-233">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="664ce-234">Bu yaklaşım kullanıldıktan sonra geliştirici \#2 ' nin yerel kod tabanı ' nın durumu aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="664ce-234">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![Birleştirme geçişi](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="664ce-236">2\. seçenek: son geçişte model anlık görüntüsünü güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="664ce-236">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="664ce-237">Bu seçenek, 1. seçeneğe çok benzer ancak daha fazla boş geçiş de kaldırılır. bu nedenle, çözümünde ek kod dosyaları istiyor.</span><span class="sxs-lookup"><span data-stu-id="664ce-237">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="664ce-238">**Bu yaklaşım yalnızca, en son geçişin yalnızca yerel kod tabanınız varsa ve henüz kaynak denetimine gönderilmediyse (örneğin, birleştirme yapan kullanıcı tarafından son geçiş oluşturulduysa) uygulanabilir**.</span><span class="sxs-lookup"><span data-stu-id="664ce-238">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="664ce-239">Diğer geliştiricilerin geliştirme veritabanına daha önce uygulamış olabileceği veya daha kötü bir üretim veritabanına uygulanan geçişlerin meta verilerini düzenlemekte, beklenmeyen yan etkilere neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-239">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="664ce-240">İşlem sırasında, yerel veritabanımızda son geçişi geri almak ve güncelleştirilmiş meta veriler ile yeniden uygulamamız istenir.</span><span class="sxs-lookup"><span data-stu-id="664ce-240">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="664ce-241">Son geçişin yalnızca yerel kod tabanında olması gerekir, ancak devam eden geçişlerin sayısı veya sırası için hiçbir kısıtlama yoktur.</span><span class="sxs-lookup"><span data-stu-id="664ce-241">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="664ce-242">Birden çok farklı geliştiriciden birden çok geçiş olabilir ve aynı adımlar geçerlidir. Bu, en basit durumda tutulması için yalnızca iki tane bakıyorduk.</span><span class="sxs-lookup"><span data-stu-id="664ce-242">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="664ce-243">Aşağıdaki işlem, kaynak denetiminden eşitlenmesi gereken değişiklikler olduğunu fark ettiğiniz zamandan itibaren bu yaklaşım için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="664ce-243">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="664ce-244">Yerel kod tabanınız içindeki bekleyen model değişikliklerinin bir geçişe yazıldığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="664ce-244">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="664ce-245">Bu adım, boş geçiş oluşturmak için zaman geldiğinde herhangi bir yasal değişikliği kaçırmamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="664ce-245">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="664ce-246">Kaynak denetimiyle eşitleyin.</span><span class="sxs-lookup"><span data-stu-id="664ce-246">Sync with the source control.</span></span>
3.  <span data-ttu-id="664ce-247">Diğer geliştiricilerin denetlediği yeni geçişleri uygulamak için **Update-Database** ' i çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="664ce-247">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="664ce-248">**_Note:_** *Update-Database komutundan herhangi bir uyarı alamazsanız, diğer geliştiricilerden yeni geçiş yoktu ve daha fazla birleştirme gerçekleştirmeye gerek yoktur.*</span><span class="sxs-lookup"><span data-stu-id="664ce-248">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="664ce-249">**Update-Database – targetmigration &lt;ikinci\_son\_geçiş&gt;** (bunu takip ettiğimiz örnekte, **Update-Database – Targetmigration addderecelendirme**) komutunu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="664ce-249">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="664ce-250">Bu, veritabanını ikinci son geçişin durumuna geri doğru şekilde, son geçiş ' i veritabanından son geçişin uygulanmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="664ce-250">This roles the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="664ce-251">**_Note:_** *meta veriler, veritabanının \_\_MigrationsHistoryTable ' da depolandığından, geçişin meta verilerini düzenlemeyi güvenli hale getirmek için bu adım gereklidir. Bu nedenle, yalnızca son geçiş yalnızca yerel kod tabanınız ise bu seçeneği kullanmanız gerekir. Diğer veritabanlarına en son geçiş uygulanmışsa, bunları yeniden almanız ve meta verileri güncelleştirmek için son geçişi yeniden uygulamanız gerekir.*</span><span class="sxs-lookup"><span data-stu-id="664ce-251">**_Note:_** *This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="664ce-252">**\_son\_geçiş\_\_zaman damgası\_dahil olmak üzere tam\_adı &lt;ekleme-geçiş** ' i çalıştırın (bunu takip ettiğimiz örnekte, **add-Migration 201311062215252&gt; addokuyucular**gibi bir şey olacaktır).\_</span><span class="sxs-lookup"><span data-stu-id="664ce-252">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="664ce-253">**_Göz önünde_** *bulundurabilmeniz için, geçişlerin yeni bir yükseltme yerine var olan geçişi düzenlemek istediğinizi bilmesi için zaman damgasını dahil etmeniz gerekir.*</span><span class="sxs-lookup"><span data-stu-id="664ce-253">**_Note:_** *You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
    <span data-ttu-id="664ce-254">Bu işlem, son geçişin meta verilerini geçerli modelle eşleşecek şekilde güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="664ce-254">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="664ce-255">Komut tamamlandığında aşağıdaki uyarıyı alırsınız, ancak tam olarak istediğiniz şeydir.</span><span class="sxs-lookup"><span data-stu-id="664ce-255">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="664ce-256">" *' 201311062215252\_Addokuyucular ' geçişi Için yalnızca Tasarımcı kodu yeniden yapı haline geçirildi. Geçişin tamamını yeniden kullanmak için-zorlama parametresini kullanın. "*</span><span class="sxs-lookup"><span data-stu-id="664ce-256">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="664ce-257">Güncelleştirilmiş meta verilerle en son geçişi yeniden uygulamak için **Update-Database** ' i çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="664ce-257">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="664ce-258">Geliştirmeye devam edin veya kaynak denetimine gönderim yapın (kendi birim testlerinizi çalıştırdıktan sonra).</span><span class="sxs-lookup"><span data-stu-id="664ce-258">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="664ce-259">Bu yaklaşım kullanıldıktan sonra geliştirici \#2 ' nin yerel kod tabanı ' nın durumu aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="664ce-259">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![Güncelleştirilmiş meta veriler](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="664ce-261">Özet</span><span class="sxs-lookup"><span data-stu-id="664ce-261">Summary</span></span>

<span data-ttu-id="664ce-262">Code First Migrations bir ekip ortamında kullanırken bazı sorunlar vardır.</span><span class="sxs-lookup"><span data-stu-id="664ce-262">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="664ce-263">Ancak, geçişlerin nasıl çalıştığını ve birleştirme çakışmalarını çözmek için bazı basit yaklaşımların bu zorlukları aşmak kolaylaşır.</span><span class="sxs-lookup"><span data-stu-id="664ce-263">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="664ce-264">Temel sorun, en son geçişte depolanan hatalı meta veriler.</span><span class="sxs-lookup"><span data-stu-id="664ce-264">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="664ce-265">Bunun nedeni, geçerli modelin ve veritabanı şemasının eşleşip eşleşmediği ve sonraki geçişte yanlış koda sahip bir şekilde algılanmamasını Code First neden olur.</span><span class="sxs-lookup"><span data-stu-id="664ce-265">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="664ce-266">Bu durum, doğru modelle boş bir geçiş üretilerek veya en son geçişte meta verileri güncelleştirerek aşılır.</span><span class="sxs-lookup"><span data-stu-id="664ce-266">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
