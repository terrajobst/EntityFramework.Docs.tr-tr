---
title: Kendi kendini takip eden varlıklar - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
ms.openlocfilehash: 3bb9759d89fbd0c10b911625aa7d0afd7747de14
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/07/2020
ms.locfileid: "78419525"
---
# <a name="self-tracking-entities"></a><span data-ttu-id="20dd9-102">Kendi kendini izleyen varlıklar</span><span class="sxs-lookup"><span data-stu-id="20dd9-102">Self-tracking entities</span></span>

> [!IMPORTANT]
> <span data-ttu-id="20dd9-103">Artık kendi kendine izleme varlıkları şablonu kullanmanızı önermiyoruz.</span><span class="sxs-lookup"><span data-stu-id="20dd9-103">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="20dd9-104">Yalnızca varolan uygulamaları desteklemek için kullanılabilir olmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-104">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="20dd9-105">Uygulamanız, varlıkların bağlantısı kesilmiş grafiklerle çalışmayı gerektiriyorsa, topluluk tarafından daha aktif olarak geliştirilen Self-Tracking-Tntities'a benzer bir teknoloji olan [İzlenebilir Varlıklar](https://trackableentities.github.io/)veya düşük düzeyli değişiklik izleme API'lerini kullanarak özel kod yazma gibi diğer alternatifleri göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="20dd9-105">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="20dd9-106">Varlık Çerçevesi tabanlı bir uygulamada, nesnelerinizdeki değişiklikleri izlemekiçin bir bağlam sorumludur.</span><span class="sxs-lookup"><span data-stu-id="20dd9-106">In an Entity Framework-based application, a context is responsible for tracking changes in your objects.</span></span> <span data-ttu-id="20dd9-107">Daha sonra veritabanındaki değişiklikleri sürdürmek için SaveChanges yöntemini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="20dd9-107">You then use the SaveChanges method to persist the changes to the database.</span></span> <span data-ttu-id="20dd9-108">N-Tier uygulamalarıyla çalışırken, varlık nesneleri genellikle bağlamdan kesilir ve değişiklikleri nasıl izleyeceğinize ve bu değişiklikleri bağlama geri bildirmeye karar vermeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-108">When working with N-Tier applications, the entity objects are usually disconnected from the context and you must decide how to track changes and report those changes back to the context.</span></span> <span data-ttu-id="20dd9-109">Kendi Kendini İzleme Varlıkları (STEs) herhangi bir katmandaki değişiklikleri izlemenize ve sonra bu değişiklikleri kaydedilecek bir bağlamda yeniden oynatmanıza yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-109">Self-Tracking Entities (STEs) can help you track changes in any tier and then replay these changes into a context to be saved.</span></span>  

<span data-ttu-id="20dd9-110">STEs'i yalnızca bağlam nesne grafiğinde yapılan değişikliklerin yapıldığı bir katmanda kullanılamıyorsa kullanın.</span><span class="sxs-lookup"><span data-stu-id="20dd9-110">Use STEs only if the context is not available on a tier where the changes to the object graph are made.</span></span> <span data-ttu-id="20dd9-111">Bağlam varsa, bağlam değişiklikleri izleme yi ilgilenecek, çünkü STS'leri kullanmaya gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="20dd9-111">If the context is available, there is no need to use STEs because the context will take care of tracking changes.</span></span>  

<span data-ttu-id="20dd9-112">Bu şablon öğesi iki .tt (metin şablonu) dosyası oluşturur:</span><span class="sxs-lookup"><span data-stu-id="20dd9-112">This template item generates two .tt (text template) files:</span></span>  

- <span data-ttu-id="20dd9-113">**Model adı\>.tt dosyası, kendi kendini izleyen varlıklar tarafından kullanılan değişiklik izleme mantığını ve kendi kendine izleme varlıkları üzerinde durum ayarlamasını sağlayan uzantı yöntemlerini içeren varlık türlerini ve yardımcı sınıfını oluşturur. \<**</span><span class="sxs-lookup"><span data-stu-id="20dd9-113">The **\<model name\>.tt** file generates the entity types and a helper class that contains the change-tracking logic that is used by self-tracking entities and the extension methods that allow setting state on self-tracking entities.</span></span>  
- <span data-ttu-id="20dd9-114">\*\* \<Model adı.\> Context.tt\*\* dosyası, **ObjectContext** ve **ObjectSet** sınıfları için **Uygulamalı Değişiklikler** yöntemlerini içeren türetilmiş bir bağlam ve uzantı sınıfı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="20dd9-114">The **\<model name\>.Context.tt** file generates a derived context and an extension class that contains **ApplyChanges** methods for the **ObjectContext** and **ObjectSet** classes.</span></span> <span data-ttu-id="20dd9-115">Bu yöntemler, veritabanındaki değişiklikleri kaydetmek için gerçekleştirilmesi gereken işlem kümesini ortaya çıkarmak için kendi kendini izleyen varlıkların grafiğinde bulunan değişiklik izleme bilgilerini inceler.</span><span class="sxs-lookup"><span data-stu-id="20dd9-115">These methods examine the change-tracking information that is contained in the graph of self-tracking entities to infer the set of operations that must be performed to save the changes in the database.</span></span>  

## <a name="get-started"></a><span data-ttu-id="20dd9-116">Başlarken</span><span class="sxs-lookup"><span data-stu-id="20dd9-116">Get Started</span></span>  

<span data-ttu-id="20dd9-117">Başlamak [için, Kendi Kendine İzleme Varlıklar Walkthrough](walkthrough.md) sayfasını ziyaret edin.</span><span class="sxs-lookup"><span data-stu-id="20dd9-117">To get started, visit the [Self-Tracking Entities Walkthrough](walkthrough.md) page.</span></span>  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a><span data-ttu-id="20dd9-118">Kendi Kendini Takip Eden Varlıklarla Çalışırken İşlevsel Hususlar</span><span class="sxs-lookup"><span data-stu-id="20dd9-118">Functional Considerations When Working with Self-Tracking Entities</span></span>  
> [!IMPORTANT]
> <span data-ttu-id="20dd9-119">Artık kendi kendine izleme varlıkları şablonu kullanmanızı önermiyoruz.</span><span class="sxs-lookup"><span data-stu-id="20dd9-119">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="20dd9-120">Yalnızca varolan uygulamaları desteklemek için kullanılabilir olmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-120">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="20dd9-121">Uygulamanız, varlıkların bağlantısı kesilmiş grafiklerle çalışmayı gerektiriyorsa, topluluk tarafından daha aktif olarak geliştirilen Self-Tracking-Tntities'a benzer bir teknoloji olan [İzlenebilir Varlıklar](https://trackableentities.github.io/)veya düşük düzeyli değişiklik izleme API'lerini kullanarak özel kod yazma gibi diğer alternatifleri göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="20dd9-121">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="20dd9-122">Kendi kendini izleyen varlıklarla çalışırken aşağıdakileri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="20dd9-122">Consider the following when working with self-tracking entities:</span></span>  

- <span data-ttu-id="20dd9-123">İstemci projenizin varlık türlerini içeren derlemeye bir başvurusu olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="20dd9-123">Make sure that your client project has a reference to the assembly containing the entity types.</span></span> <span data-ttu-id="20dd9-124">İstemci projeye yalnızca hizmet başvurusu eklerseniz, istemci proje gerçek kendi kendini izleyen varlık türlerini değil, WCF proxy türlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="20dd9-124">If you add only the service reference to the client project, the client project will use the WCF proxy types and not the actual self-tracking entity types.</span></span> <span data-ttu-id="20dd9-125">Bu, istemcideki varlıkların izlenmesini yöneten otomatik bildirim özelliklerini almeyeceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-125">This means that you will not get the automated notification features that manage the tracking of the entities on the client.</span></span> <span data-ttu-id="20dd9-126">Varlık türlerini kasıtlı olarak eklemek istemiyorsanız, değişikliklerin hizmete geri gönderilmesi için istemcideki değişiklik izleme bilgilerini el ile ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-126">If you intentionally do not want to include the entity types, you will have to manually set change-tracking information on the client for the changes to be sent back to the service.</span></span>  
- <span data-ttu-id="20dd9-127">Hizmet işlemine yapılan çağrılar devletsiz olmalı ve nesne bağlamının yeni bir örneğini oluşturmalı.</span><span class="sxs-lookup"><span data-stu-id="20dd9-127">Calls to the service operation should be stateless and create a new instance of object context.</span></span> <span data-ttu-id="20dd9-128">Ayrıca, nesne bağlamı **kullanarak** bir blok oluşturmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="20dd9-128">We also recommend that you create object context in a **using** block.</span></span>  
- <span data-ttu-id="20dd9-129">İstemci üzerinde değiştirilen grafiği hizmete gönderdiğinizde ve ardından istemci üzerinde aynı grafikle çalışmaya devam etmeyi planladığında, değişiklik izleyicisini sıfırlamak için grafikte el ile yinele ve her nesnedeki **AcceptChanges** yöntemini aramanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-129">When you send the graph that was modified on the client to the service and then intend to continue working with the same graph on the client, you have to manually iterate through the graph and call the **AcceptChanges** method on each object to reset the change tracker.</span></span>  

    > <span data-ttu-id="20dd9-130">Grafiğinizdeki nesneler veritabanı tarafından oluşturulan değerlere (örneğin, kimlik veya eşzamanlılık değerleri) sahip özellikler içeriyorsa, Varlık Çerçevesi, **SaveChanges** yöntemi çağrıldıktan sonra bu özelliklerin değerlerini veritabanı tarafından oluşturulan değerlerle değiştirir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-130">If objects in your graph contain properties with database-generated values (for example, identity or concurrency values), Entity Framework will replace values of these properties with the database-generated values after the **SaveChanges** method is called.</span></span> <span data-ttu-id="20dd9-131">Kaydedilen nesneleri döndürmek için hizmet işleminizi veya istemciye geri dönen nesneler için oluşturulan özellik değerlerinin listesini uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="20dd9-131">You can implement your service operation to return saved objects or a list of generated property values for the objects back to the client.</span></span> <span data-ttu-id="20dd9-132">İstemci daha sonra nesne örnekleri veya nesne özellik değerlerini hizmet işleminden döndürülen nesneler veya özellik değerleriyle değiştirmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-132">The client would then need to replace the object instances or object property values with the objects or property values returned from the service operation.</span></span>  
- <span data-ttu-id="20dd9-133">Birden çok hizmet isteğinden grafiklerin birleştirilmesi, ortaya çıkan grafikte yinelenen anahtar değerleri olan nesneleri tanıtabilir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-133">Merging graphs from multiple service requests may introduce objects with duplicate key values in the resulting graph.</span></span> <span data-ttu-id="20dd9-134">Entity Framework, **ApplyChanges** yöntemini aradiğinizde yinelenen anahtarlarla nesneleri kaldırmaz, bunun yerine bir özel durum atar.</span><span class="sxs-lookup"><span data-stu-id="20dd9-134">Entity Framework does not remove the objects with duplicate keys when you call the **ApplyChanges** method but instead throws an exception.</span></span> <span data-ttu-id="20dd9-135">Yinelenen anahtar değerlere sahip grafiklerin olmasını önlemek için aşağıdaki blogda açıklanan desenlerden birini izleyin: [Kendi Kendine İzleme Varlıkları: Değişiklikleri Uygula ve yinelenen varlıklar.](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409)</span><span class="sxs-lookup"><span data-stu-id="20dd9-135">To avoid having graphs with duplicate key values follow one of the patterns described in the following blog: [Self-Tracking Entities: ApplyChanges and duplicate entities](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).</span></span>  
- <span data-ttu-id="20dd9-136">Yabancı anahtar özelliğini ayarlayarak nesneler arasındaki ilişkiyi değiştirdiğinizde, başvuru navigasyon özelliği null olarak ayarlanır ve istemcideki ilgili asıl varlıkla eşitlenmemiş olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="20dd9-136">When you change the relationship between objects by setting the foreign key property, the reference navigation property is set to null and not synchronized to the appropriate principal entity on the client.</span></span> <span data-ttu-id="20dd9-137">Grafik nesne bağlamına iliştirildikten sonra (örneğin, **Değişiklikleri Uygula** yöntemini aradıktan sonra), yabancı anahtar özellikleri ve gezinti özellikleri eşitlenir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-137">After the graph is attached to the object context (for example, after you call the **ApplyChanges** method), the foreign key properties and navigation properties are synchronized.</span></span>  

    > <span data-ttu-id="20dd9-138">Yabancı anahtar ilişkisinde basamaklı silme yi belirttiyseniz, uygun ana nesneyle eşitlenmiş bir başvuru gezinti özelliğinin olmaması sorun olabilir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-138">Not having a reference navigation property synchronized with the appropriate principal object could be an issue if you have specified cascade delete on the foreign key relationship.</span></span> <span data-ttu-id="20dd9-139">Anaparayı silerseniz, silme bağımlı nesnelere yayılmaz.</span><span class="sxs-lookup"><span data-stu-id="20dd9-139">If you delete the principal, the delete will not be propagated to the dependent objects.</span></span> <span data-ttu-id="20dd9-140">Belirtilen basamaklı silmeleriniz varsa, yabancı anahtar özelliğini ayarlamak yerine ilişkileri değiştirmek için gezinti özelliklerini kullanın.</span><span class="sxs-lookup"><span data-stu-id="20dd9-140">If you have cascade deletes specified, use navigation properties to change relationships instead of setting the foreign key property.</span></span>  
- <span data-ttu-id="20dd9-141">Kendi kendine izleme varlıklar tembel yükleme gerçekleştirmek için etkin değildir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-141">Self-tracking entities are not enabled to perform lazy loading.</span></span>  
- <span data-ttu-id="20dd9-142">ASP.NET durum yönetimi nesneleri için ikili serileştirme ve serileştirme kendi kendini izleyen varlıklar tarafından desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="20dd9-142">Binary serialization and serialization to ASP.NET state management objects is not supported by self-tracking entities.</span></span> <span data-ttu-id="20dd9-143">Ancak, ikili serileştirme desteği eklemek için şablonu özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="20dd9-143">However, you can customize the template to add the binary serialization support.</span></span> <span data-ttu-id="20dd9-144">Daha fazla bilgi için, [Kendi Kendini İzleme Varlıkları ile İkili Serileştirme ve ViewState kullanma](https://go.microsoft.com/fwlink/?LinkId=199208)bakın.</span><span class="sxs-lookup"><span data-stu-id="20dd9-144">For more information, see [Using Binary Serialization and ViewState with Self-Tracking Entities](https://go.microsoft.com/fwlink/?LinkId=199208).</span></span>  

## <a name="security-considerations"></a><span data-ttu-id="20dd9-145">Güvenlikle İlgili Dikkat Edilmesi Gerekenler</span><span class="sxs-lookup"><span data-stu-id="20dd9-145">Security Considerations</span></span>  

<span data-ttu-id="20dd9-146">Kendi kendini izleyen varlıklarla çalışırken aşağıdaki güvenlik hususları göz önünde bulundurulmalıdır:</span><span class="sxs-lookup"><span data-stu-id="20dd9-146">The following security considerations should be taken into account when working with self-tracking entities:</span></span>  

- <span data-ttu-id="20dd9-147">Bir hizmet, güvenilmeyen bir istemciden veya güvenilmeyen bir kanaldan veri alma veya güncelleştirme isteklerine güvenmemelidir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-147">A service should not trust requests to retrieve or update data from a non-trusted client or through a non-trusted channel.</span></span> <span data-ttu-id="20dd9-148">İstemcinin kimliği doğrulanmalıdır: güvenli bir kanal veya ileti zarfı kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="20dd9-148">A client must be authenticated: a secure channel or message envelope should be used.</span></span> <span data-ttu-id="20dd9-149">İstemcilerin verileri güncelleştirme veya alma istekleri, verilen senaryo için beklenen ve meşru değişikliklere uyduklarından emin olmak için doğrulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="20dd9-149">Clients' requests to update or retrieve data must be validated to ensure they conform to expected and legitimate changes for the given scenario.</span></span>  
- <span data-ttu-id="20dd9-150">Hassas bilgileri varlık anahtarı (örneğin, sosyal güvenlik numaraları) olarak kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="20dd9-150">Avoid using sensitive information as entity keys (for example, social security numbers).</span></span> <span data-ttu-id="20dd9-151">Bu, kendi kendine izleme varlık grafiklerinde bulunan ve tam olarak güvenilmeyen bir istemciye, farkında olmadan hassas bilgileri serileştirme olasılığını azaltır.</span><span class="sxs-lookup"><span data-stu-id="20dd9-151">This mitigates the possibility of inadvertently serializing sensitive information in the self-tracking entity graphs to a client that is not fully trusted.</span></span> <span data-ttu-id="20dd9-152">Bağımsız ilişkilendirmelerle, serihale edilen varlıkla ilgili bir varlığın özgün anahtarı istemciye de gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="20dd9-152">With independent associations, the original key of an entity that is related to the one that is being serialized might be sent to the client as well.</span></span>  
- <span data-ttu-id="20dd9-153">Önemli verileri istemci katmanına içeren özel durum iletilerinin yayılmasını önlemek için, sunucu katmanındaki **Değişiklikleri Uygula** ve **Kaydet** çağrıları özel durum işleme koduna sarılı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="20dd9-153">To avoid propagating exception messages that contain sensitive data to the client tier, calls to **ApplyChanges** and **SaveChanges** on the server tier should be wrapped in exception-handling code.</span></span>  
