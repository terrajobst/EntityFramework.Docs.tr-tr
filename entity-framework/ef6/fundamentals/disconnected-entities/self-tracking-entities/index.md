---
title: Kendi kendine izleme varlıkları-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
ms.openlocfilehash: 3bb9759d89fbd0c10b911625aa7d0afd7747de14
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/09/2019
ms.locfileid: "72181724"
---
# <a name="self-tracking-entities"></a><span data-ttu-id="9e362-102">Kendi kendine izleme varlıkları</span><span class="sxs-lookup"><span data-stu-id="9e362-102">Self-tracking entities</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9e362-103">Artık kendi kendine izleme varlıkları şablonunu kullanmanızı önermiyoruz.</span><span class="sxs-lookup"><span data-stu-id="9e362-103">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="9e362-104">Yalnızca var olan uygulamaları desteklemek için kullanılabilir olmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="9e362-104">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="9e362-105">Uygulamanız, bağlantısı kesilen varlıkların, topluluk tarafından daha etkin bir şekilde geliştirilen veya yazma gibi, kendi kendini Izlemeye benzer bir teknoloji olan, [izleyicileri](https://trackableentities.github.io/)olan diğer alternatifleri göz önünde bulundurun. alt düzey değişiklik izleme API 'Lerini kullanan özel kod.</span><span class="sxs-lookup"><span data-stu-id="9e362-105">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="9e362-106">Entity Framework tabanlı bir uygulamada, nesnelerdeki değişiklikleri izlemeden bir bağlam sorumludur.</span><span class="sxs-lookup"><span data-stu-id="9e362-106">In an Entity Framework-based application, a context is responsible for tracking changes in your objects.</span></span> <span data-ttu-id="9e362-107">Sonra değişiklikleri veritabanında kalıcı hale getirmek için SaveChanges yöntemini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="9e362-107">You then use the SaveChanges method to persist the changes to the database.</span></span> <span data-ttu-id="9e362-108">N katmanlı uygulamalarla çalışırken, varlık nesnelerinin genellikle bağlamla bağlantısı kesilir ve değişikliklerin nasıl izleneceğini ve bu değişiklikleri içeriğe geri rapor etmeniz gerektiğine karar vermeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="9e362-108">When working with N-Tier applications, the entity objects are usually disconnected from the context and you must decide how to track changes and report those changes back to the context.</span></span> <span data-ttu-id="9e362-109">Kendi kendini izleyen varlıklar (Steler), herhangi bir katmandaki değişiklikleri izlemenize ve sonra bu değişiklikleri kaydedilecek bir bağlamda yeniden yürütmeye yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="9e362-109">Self-Tracking Entities (STEs) can help you track changes in any tier and then replay these changes into a context to be saved.</span></span>  

<span data-ttu-id="9e362-110">Yalnızca bağlam, nesne grafiğinde yapılan değişikliklerin yapıldığı bir katmanda kullanılabilir değilse, STEs 'yi kullanın.</span><span class="sxs-lookup"><span data-stu-id="9e362-110">Use STEs only if the context is not available on a tier where the changes to the object graph are made.</span></span> <span data-ttu-id="9e362-111">Bağlam kullanılabiliyorsa, bağlam değişiklikleri izlemek için gereken bir işlem olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="9e362-111">If the context is available, there is no need to use STEs because the context will take care of tracking changes.</span></span>  

<span data-ttu-id="9e362-112">Bu şablon öğesi iki. tt (metin şablonu) dosyası oluşturur:</span><span class="sxs-lookup"><span data-stu-id="9e362-112">This template item generates two .tt (text template) files:</span></span>  

- <span data-ttu-id="9e362-113">**@No__t-1model Name\>.tt** dosyası, kendi kendine izleme varlıkları ve kendi kendini takip eden varlıklarda ayar durumuna izin veren genişletme yöntemleri tarafından kullanılan değişiklik izleme mantığını içeren bir yardımcı sınıfı ve varlık türlerini üretir.</span><span class="sxs-lookup"><span data-stu-id="9e362-113">The **\<model name\>.tt** file generates the entity types and a helper class that contains the change-tracking logic that is used by self-tracking entities and the extension methods that allow setting state on self-tracking entities.</span></span>  
- <span data-ttu-id="9e362-114">**@No__t-1model adı @ no__t-2. Context.tt** dosyası türetilmiş bir bağlam ve **ObjectContext** ve **ObjectSet** sınıfları için **ApplyChanges** yöntemlerini içeren bir uzantı sınıfı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9e362-114">The **\<model name\>.Context.tt** file generates a derived context and an extension class that contains **ApplyChanges** methods for the **ObjectContext** and **ObjectSet** classes.</span></span> <span data-ttu-id="9e362-115">Bu yöntemler, değişiklikleri veritabanına kaydetmek için gerçekleştirilmesi gereken işlemler kümesini çıkarması için kendi kendine izleme varlıklarının grafiğinde bulunan değişiklik izleme bilgilerini inceler.</span><span class="sxs-lookup"><span data-stu-id="9e362-115">These methods examine the change-tracking information that is contained in the graph of self-tracking entities to infer the set of operations that must be performed to save the changes in the database.</span></span>  

## <a name="get-started"></a><span data-ttu-id="9e362-116">Başlarken</span><span class="sxs-lookup"><span data-stu-id="9e362-116">Get Started</span></span>  

<span data-ttu-id="9e362-117">Başlamak için, [kendi kendine Izleme varlıkları Izlenecek yol](walkthrough.md) sayfasını ziyaret edin.</span><span class="sxs-lookup"><span data-stu-id="9e362-117">To get started, visit the [Self-Tracking Entities Walkthrough](walkthrough.md) page.</span></span>  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a><span data-ttu-id="9e362-118">Kendi kendine Izleme varlıklarıyla çalışırken işlevsel konular</span><span class="sxs-lookup"><span data-stu-id="9e362-118">Functional Considerations When Working with Self-Tracking Entities</span></span>  
> [!IMPORTANT]
> <span data-ttu-id="9e362-119">Artık kendi kendine izleme varlıkları şablonunu kullanmanızı önermiyoruz.</span><span class="sxs-lookup"><span data-stu-id="9e362-119">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="9e362-120">Yalnızca var olan uygulamaları desteklemek için kullanılabilir olmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="9e362-120">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="9e362-121">Uygulamanız, bağlantısı kesilen varlıkların, topluluk tarafından daha etkin bir şekilde geliştirilen veya yazma gibi, kendi kendini Izlemeye benzer bir teknoloji olan, [izleyicileri](https://trackableentities.github.io/)olan diğer alternatifleri göz önünde bulundurun. alt düzey değişiklik izleme API 'Lerini kullanan özel kod.</span><span class="sxs-lookup"><span data-stu-id="9e362-121">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="9e362-122">Kendi kendine izleme varlıklarıyla çalışırken aşağıdakileri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="9e362-122">Consider the following when working with self-tracking entities:</span></span>  

- <span data-ttu-id="9e362-123">İstemci projenizin varlık türlerini içeren derlemeye bir başvurusu olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="9e362-123">Make sure that your client project has a reference to the assembly containing the entity types.</span></span> <span data-ttu-id="9e362-124">İstemci projesine yalnızca hizmet başvurusunu eklerseniz, istemci projesi gerçek kendi kendini izleyen varlık türlerini değil, WCF proxy türlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="9e362-124">If you add only the service reference to the client project, the client project will use the WCF proxy types and not the actual self-tracking entity types.</span></span> <span data-ttu-id="9e362-125">Bu, istemci üzerindeki varlıkların izlenmesini yöneten otomatik bildirim özelliklerini alacağınız anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="9e362-125">This means that you will not get the automated notification features that manage the tracking of the entities on the client.</span></span> <span data-ttu-id="9e362-126">Özellikle varlık türlerini eklemek istemiyorsanız, hizmete geri gönderilecek değişiklikler için istemcideki değişiklik izleme bilgilerini el ile ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9e362-126">If you intentionally do not want to include the entity types, you will have to manually set change-tracking information on the client for the changes to be sent back to the service.</span></span>  
- <span data-ttu-id="9e362-127">Hizmet işlemine yapılan çağrılar durum bilgisiz olmalıdır ve yeni bir nesne bağlamı örneği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9e362-127">Calls to the service operation should be stateless and create a new instance of object context.</span></span> <span data-ttu-id="9e362-128">Ayrıca, bir **using** bloğunda nesne bağlamı oluşturmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="9e362-128">We also recommend that you create object context in a **using** block.</span></span>  
- <span data-ttu-id="9e362-129">İstemcide değiştirilmiş olan grafiği hizmete gönderdiğinizde ve sonra istemcide aynı grafikle çalışmaya devam etmeyi planlıyorsanız, grafiği el ile yinelemek ve değişikliği sıfırlamak için her nesne üzerinde **AcceptChanges** yöntemini çağırmanız gerekir ýndan.</span><span class="sxs-lookup"><span data-stu-id="9e362-129">When you send the graph that was modified on the client to the service and then intend to continue working with the same graph on the client, you have to manually iterate through the graph and call the **AcceptChanges** method on each object to reset the change tracker.</span></span>  

    > <span data-ttu-id="9e362-130">Grafiğinizde nesneler veritabanı tarafından oluşturulan değerlerle (örneğin, kimlik veya eşzamanlılık değerleri) özellikler içeriyorsa Entity Framework, bu özelliklerin değerleri, **SaveChanges** yöntemi olduktan sonra veritabanı tarafından oluşturulan değerlerle değiştirilir çağırılır.</span><span class="sxs-lookup"><span data-stu-id="9e362-130">If objects in your graph contain properties with database-generated values (for example, identity or concurrency values), Entity Framework will replace values of these properties with the database-generated values after the **SaveChanges** method is called.</span></span> <span data-ttu-id="9e362-131">Kaydedilmiş nesneleri ya da nesneler için oluşturulan özellik değerlerinin bir listesini istemciye geri döndürmek için hizmet işleminizi uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9e362-131">You can implement your service operation to return saved objects or a list of generated property values for the objects back to the client.</span></span> <span data-ttu-id="9e362-132">Daha sonra istemci, nesne örnekleri veya nesne özelliği değerlerini hizmet işleminden döndürülen nesneler veya özellik değerleriyle değiştirmek zorunda olur.</span><span class="sxs-lookup"><span data-stu-id="9e362-132">The client would then need to replace the object instances or object property values with the objects or property values returned from the service operation.</span></span>  
- <span data-ttu-id="9e362-133">Birden çok hizmet isteğinin grafiklerini birleştirme, sonuçta elde edilen grafikte yinelenen anahtar değerleriyle nesneleri ortaya çıkarabilir.</span><span class="sxs-lookup"><span data-stu-id="9e362-133">Merging graphs from multiple service requests may introduce objects with duplicate key values in the resulting graph.</span></span> <span data-ttu-id="9e362-134">Entity Framework **ApplyChanges** metodunu çağırdığınızda yinelenen anahtarlarla nesneleri kaldırmaz, ancak bunun yerine bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9e362-134">Entity Framework does not remove the objects with duplicate keys when you call the **ApplyChanges** method but instead throws an exception.</span></span> <span data-ttu-id="9e362-135">Yinelenen anahtar değerleriyle grafiklerin oluşmasını önlemek için, aşağıdaki blogda açıklanan desenlerden birini izleyin: [Kendi kendine Izleme varlıkları: ApplyChanges ve yinelenen varlıklar @ no__t-0.</span><span class="sxs-lookup"><span data-stu-id="9e362-135">To avoid having graphs with duplicate key values follow one of the patterns described in the following blog: [Self-Tracking Entities: ApplyChanges and duplicate entities](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).</span></span>  
- <span data-ttu-id="9e362-136">Yabancı anahtar özelliğini ayarlayarak nesneler arasındaki ilişkiyi değiştirdiğinizde, başvuru gezintisi özelliği null olarak ayarlanır ve istemcideki uygun asıl varlıkla eşitlenmez.</span><span class="sxs-lookup"><span data-stu-id="9e362-136">When you change the relationship between objects by setting the foreign key property, the reference navigation property is set to null and not synchronized to the appropriate principal entity on the client.</span></span> <span data-ttu-id="9e362-137">Grafik nesne bağlamına eklendikten sonra (örneğin, **ApplyChanges** yöntemini çağırdıktan sonra), yabancı anahtar özellikleri ve gezinti özellikleri eşitlenir.</span><span class="sxs-lookup"><span data-stu-id="9e362-137">After the graph is attached to the object context (for example, after you call the **ApplyChanges** method), the foreign key properties and navigation properties are synchronized.</span></span>  

    > <span data-ttu-id="9e362-138">Yabancı anahtar ilişkisinde basamaklı silme belirttiyseniz, başvuru gezintisi özelliğinin uygun asıl nesneyle eşitlenmiş olmadığı bir sorun olabilir.</span><span class="sxs-lookup"><span data-stu-id="9e362-138">Not having a reference navigation property synchronized with the appropriate principal object could be an issue if you have specified cascade delete on the foreign key relationship.</span></span> <span data-ttu-id="9e362-139">Sorumluyu silerseniz, silme bağımlı nesnelere yayılmaz.</span><span class="sxs-lookup"><span data-stu-id="9e362-139">If you delete the principal, the delete will not be propagated to the dependent objects.</span></span> <span data-ttu-id="9e362-140">Art arda silme belirtilirse, yabancı anahtar özelliğini ayarlamak yerine ilişkileri değiştirmek için gezinti özelliklerini kullanın.</span><span class="sxs-lookup"><span data-stu-id="9e362-140">If you have cascade deletes specified, use navigation properties to change relationships instead of setting the foreign key property.</span></span>  
- <span data-ttu-id="9e362-141">Kendi kendini izleyen varlıklar, yavaş yükleme gerçekleştirmek için etkin değildir.</span><span class="sxs-lookup"><span data-stu-id="9e362-141">Self-tracking entities are not enabled to perform lazy loading.</span></span>  
- <span data-ttu-id="9e362-142">İkili serileştirme ve ASP.NET durum yönetimi nesnelerine serileştirme, kendi kendine izleme varlıkları tarafından desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="9e362-142">Binary serialization and serialization to ASP.NET state management objects is not supported by self-tracking entities.</span></span> <span data-ttu-id="9e362-143">Ancak, ikili serileştirme desteğini eklemek için şablonu özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9e362-143">However, you can customize the template to add the binary serialization support.</span></span> <span data-ttu-id="9e362-144">Daha fazla bilgi için, bkz. [Ikili serileştirme ve kendi kendine Izleme varlıkları Ile ViewState kullanma](https://go.microsoft.com/fwlink/?LinkId=199208).</span><span class="sxs-lookup"><span data-stu-id="9e362-144">For more information, see [Using Binary Serialization and ViewState with Self-Tracking Entities](https://go.microsoft.com/fwlink/?LinkId=199208).</span></span>  

## <a name="security-considerations"></a><span data-ttu-id="9e362-145">Güvenlik Değerlendirmeleri</span><span class="sxs-lookup"><span data-stu-id="9e362-145">Security Considerations</span></span>  

<span data-ttu-id="9e362-146">Kendi kendine izleme varlıklarıyla çalışırken aşağıdaki güvenlik konuları dikkate alınmalıdır:</span><span class="sxs-lookup"><span data-stu-id="9e362-146">The following security considerations should be taken into account when working with self-tracking entities:</span></span>  

- <span data-ttu-id="9e362-147">Hizmet, güvenilir olmayan bir istemciden veya güvenilmeyen bir kanaldan veri alma veya güncelleştirme isteklerine güvenmemelidir.</span><span class="sxs-lookup"><span data-stu-id="9e362-147">A service should not trust requests to retrieve or update data from a non-trusted client or through a non-trusted channel.</span></span> <span data-ttu-id="9e362-148">İstemcinin kimliği doğrulanmalıdır: güvenli bir kanal veya ileti zarfı kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="9e362-148">A client must be authenticated: a secure channel or message envelope should be used.</span></span> <span data-ttu-id="9e362-149">Verilen senaryoya ilişkin beklenen ve meşru değişikliklere uyduğundan emin olmak için istemcilerin verileri güncelleştirme veya alma isteklerinin doğrulanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="9e362-149">Clients' requests to update or retrieve data must be validated to ensure they conform to expected and legitimate changes for the given scenario.</span></span>  
- <span data-ttu-id="9e362-150">Gizli bilgileri varlık anahtarları (örneğin, sosyal güvenlik numaraları) olarak kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="9e362-150">Avoid using sensitive information as entity keys (for example, social security numbers).</span></span> <span data-ttu-id="9e362-151">Bu, kendi kendini takip eden varlık grafiklerde hassas bilgileri tam güvenilir olmayan bir istemciye yanlışlıkla serileştirmek olasılığını azaltır.</span><span class="sxs-lookup"><span data-stu-id="9e362-151">This mitigates the possibility of inadvertently serializing sensitive information in the self-tracking entity graphs to a client that is not fully trusted.</span></span> <span data-ttu-id="9e362-152">Bağımsız İlişkilendirmelerde, serileştirilmekte olan varlıkla ilişkili bir varlığın özgün anahtarı da istemciye gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="9e362-152">With independent associations, the original key of an entity that is related to the one that is being serialized might be sent to the client as well.</span></span>  
- <span data-ttu-id="9e362-153">Gizli veriler içeren özel durum iletilerini istemci katmanına yaymamak için sunucu katmanındaki **ApplyChanges** ve **SaveChanges** çağrılarına özel durum işleme kodunda sarmalanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="9e362-153">To avoid propagating exception messages that contain sensitive data to the client tier, calls to **ApplyChanges** and **SaveChanges** on the server tier should be wrapped in exception-handling code.</span></span>  
